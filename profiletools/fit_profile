#!/usr/bin/env python2.7
# Copyright 2014 Mark Chilenski
# This program is distributed under the terms of the GNU General Purpose License (GPL).
# Refer to http://www.gnu.org/licenses/gpl.txt
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import division

__version__ = '0.0'

# Configure and parse command line arguments:
import argparse

class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter):
    pass

parser = argparse.ArgumentParser(
    description=
"""Fit univariate profile using gptools/profiletools.

BASIC USAGE DETAILS:

Calling without arguments will enter an interactive mode, but it will only
prompt you for the most basic parameters needed. Use the command line flags to
specify more advanced options. This program can operate on ne, Te data from the
tree, or you can provide data in a NetCDF or CSV file.

You can choose whether to average over a time window, a specific set of points
or to use a single time slice. Even if providing data in a file, you should
specify the shot number and time window so that appropriate constraints can be
imposed on the fit at the magnetic axis and edge.

EXAMPLES:

Basic way to fit ne profile from shot 1101014006, averaged over the flat top
from 0.965s to 1.365s, using core and edge TS:

    fit_profile --shot 1101014006 --signal ne --t-min 0.965 --t-max 1.365

(To specify specific diagnostics to include, use the --system keyword.)

Basic way to fit data from NetCDF file foo.nc, assuming the data are from the
time window 0.965s to 1.365s of shot 1101014006. The abscissa is specified to be
normalized poloidal flux and is stored in the variable psin in the NetCDF file.
The ordinate is stored in the variable q and its uncertainty in err_q:

    fit_profile -i foo.nc --coordinate psinorm --t-min 0.965 --t-max 1.365 -x psin -y q

When the fit is complete, you will be presented with a plot of the fit and its
uncertainty. You will then have the option to reject the fit and exit (with
status code 2), or to accept the fit and exit (with status code 0). Upon
accepting the fit, the data will be saved to either a NetCDF file or a CSV file,
depending on the extension of the output filename you specify.

FIXING/IMPROVING THE FIT:

Several things can go wrong in the fit. If there are bad points/outliers in your
data you can attempt to remove them by specifying one or both of
--change-threshold and --outlier-threshold. Change threshold rejects points that
are too distant from their neighbors, outlier threshold rejects points that are
too distant from the fit.

If there are not apparent outliers, but the fit still looks bad, then there is
likely an issue with the estimation of the fit's properties -- namely the
so-called hyperparameters that dictate the spatial correlation between points.
Try increasing the --random-starts flag to at least 8 as a first cut. This will
make the fit take quite a bit longer, but is parallelized, so the more cores
your computer has, the faster you will have your answer. If this still yields
unsatisfactory fits, try adjusting the bounds for the hyperparameters using
--bounds.

Note that many warnings regarding overflow in cosh and casting complex values
will be emitted -- these are usually benign. You will also see warnings that
the minimizer failed. These indicate that a particular random guess for the 
hyperparameters walked the minimizer into a bad state. At the end of the
optimization you will be told how many starts were accepted. Try to increase
--random-starts and/or adjust --bounds until this number is at least 4.

Note that, at this point, the program only supports handling of the
hyperparameters through MAP estimation. This is usually sufficient for the value
in the core, but is NOT sufficient for getting uncertainties on gradients (even
in the core) or detailed information on the edge.

READING FROM FILES:

The support for reading data from NetCDF and CSV files is fairly powerful. With
either type of file, you can specify the column/variable names to be of the form
"name [units]" which will be automatically parsed to generate the right plot
labels. (Though it is better to just set the "units" attribute of each variable
in your NetCDF file, which is the preferred approach there.) The CSV reader is
smart enough to figure out your column names, as long as you put the time column
first when using data you haven't time-averaged yet. In either type of file you
can include the metadata needed to apply core/edge constraints. For CSV files,
start the file with as many lines needed of the form "name data" or
"name data,data,..." Be sure to specify --metadata-lines when doing this! For
NetCDF files, simply place the metadata in the appropriate attributes of the
file. The supported metadata are:

        ========== =======================================================
        shot       shot number
        times      comma-separated list of times included in the data
        t_min      minimum time included in the data
        t_max      maximum time included in the data
        coordinate the abscissa the data are represented as a function of,
                   valid choices are:
                   {psinorm,Rmid,r/a,volnorm,phinorm,sqrtpsinorm,sqrtr/a,
                    sqrtvolnorm,sqrtphinorm}
        ========== =======================================================
""",
    formatter_class=CustomFormatter
)
parser.add_argument('--signal',
                    choices=['ne', 'Te'],
                    help="Which signal to fit when pulling data from the tree.")
parser.add_argument('--shot',
                    type=int,
                    help="Shot number to use. Required when pulling data from "
                         "the tree. When pulling data from a file, this is "
                         "needed to specify constraints at the magnetic axis and "
                         "limiter.")
parser.add_argument('--t-min',
                    type=float,
                    help="Starting time of period to average over. If you are "
                         "reading data from a file, you can set this flag to "
                         "tell the program what time window to average over "
                         "when finding the location of the limiter/magnetic axis "
                         "when applying constraints.")
parser.add_argument('--t-max',
                    type=float,
                    help="Ending time of period to average over. If you are "
                         "reading data from a file, you can set this flag to "
                         "tell the program what time window to average over when "
                         "finding the location of the limiter/magnetic axis "
                         "when applying constraints.")
parser.add_argument('-t', '--t-points',
                    type=float,
                    nargs='+',
                    help="Individual time values to use. The nearest time to "
                         "each will be selected for each channel. You can use "
                         "this, for instance, to specify the times you have "
                         "determined are at a particular sawtooth/ELM phase. You "
                         "must either specify --t-min and --t-max, or -t.")
parser.add_argument('--npts',
                    type=int,
                    default=400,
                    help="Number of evenly-spaced points to evaluate the fit at.")
parser.add_argument('--x-min',
                    type=float,
                    default=0,
                    help="Starting point for the evenly-spaced points to evaluate "
                         "the fit at.")
parser.add_argument('--x-max',
                    type=float,
                    default=1.2,
                    help="Ending point for the evenly-spaced points to evaluate "
                         "the fit at.")
parser.add_argument('--x-pts',
                    type=float,
                    nargs='+',
                    help="Discrete points to evaluate the fit at. If present, "
                         "this overrides the effect of npts, x-min and x-max.")
parser.add_argument('--system',
                    nargs='+',
                    choices=['CTS', 'ETS', 'TS', 'GPC', 'GPC2', 'FRCECE'],
                    help="Which system(s) to take data from. If not provided, "
                         "all applicable systems will be used. The 'TS' option "
                         "is a shortcut to include both the core (CTS) and edge "
                         "(ETS) Thomson systems.")
parser.add_argument('--kernel',
                    choices=['gibbstanh', 'SE'],
                    default='gibbstanh',
                    help="Which covariance kernel to use. This dictates the "
                         "properties of the fit. SE is the squared exponential "
                         "kernel, which is good for core data. gibbstanh is the "
                         "Gibbs kernel with tanh warping of the length scale. "
                         "This kernel allows the entire profile to be fit at "
                         "once, and should be used if you have edge data. You "
                         "will typically also want to use --no-edge-constraint "
                         "if you specify the SE kernel. See also --core-only.")
parser.add_argument('--coordinate',
                    choices=['psinorm', 'Rmid', 'r/a', 'volnorm', 'phinorm',
                             'sqrtpsinorm', 'sqrtr/a', 'sqrtvolnorm', 'sqrtphinorm'],
                    default='',
                    help="Which coordinate to fit against. Defaults to psinorm "
                         "when pulling data from the tree. Used to determine how "
                         "to apply core/edge constraints when pulling data from "
                         "a file.")
parser.add_argument('--no-core-constraint',
                    action='store_true',
                    help="Set this flag to disable the slope=0 constraint at the "
                         "magnetic axis.")
parser.add_argument('--no-edge-constraint',
                    action='store_true',
                    help="Set this flag to disable the slope, value=0 constraint "
                         "at/outside the GH limiter.")
parser.add_argument('--core-constraint-location',
                    type=float,
                    help="Location to impose slope=0 constraint at. Typically "
                         "this is the magnetic axis. If you specify a shot "
                         "number and times then this will be found automatically, "
                         "but you can override it with this flag.")
parser.add_argument('--edge-constraint-locations',
                    type=float,
                    nargs='+',
                    help="Location to impose slope~0, value~0 constraints at. "
                         "Typically this is at the location of the GH limiter. "
                         "If you specify a shot number and times then this will "
                         "be found automatically, but you can override it with "
                         "this flag. It helps to specify a couple of points "
                         "outside the GH limiter, as well.")
parser.add_argument('--core-only',
                    action='store_true',
                    help="Set this flag to only fit the data inside the LCFS. "
                         "This will switch to using a squared exponential kernel, "
                         "and will disable the edge value, slope constraints.")
parser.add_argument('--robust',
                    action='store_true',
                    help="Set this flag to use robust estimators (median, IQR) "
                         "when performing time-averages.")
parser.add_argument('--uncertainty-method',
                    choices=['sample', 'RMS', 'total'],
                    default='sample',
                    help="Method by which the uncertainty should be propagated "
                         "when time-averaging. sample will take the sample "
                         "standard deviation, and is usually appropriate for "
                         "cases where you have many points to average over. "
                         "RMS uses the root-mean-square standard deviation, and "
                         "is appropriate for small sample sizes. total uses the "
                         "law of total variance which is the square root of the "
                         "sum of the mean square uncertainty and sample variance. "
                         "This is appropriate when the given points already "
                         "represent actual sample means/variances.")
parser.add_argument('--all-points', '--no-average',
                    action='store_true',
                    help="Set this flag to keep all points from the time window "
                         "selected instead of performing a time average. This "
                         "will make the fit take longer and is statistically-"
                         "questionable, but may be useful in some cases.")
parser.add_argument('--change-threshold',
                    type=float,
                    help="If provided, any points whose differences with respect "
                         "to either of their neighbors are more than this many "
                         "times their own error bar will be rejected. This is "
                         "useful for getting rid of bad channels. A value of 9 "
                         "is often useful.")
parser.add_argument('--outlier-threshold',
                    type=float,
                    help="If provided, any points whose values are more than this "
                         "many times their own error bar outside of the fit will "
                         "be rejected. A value of 3 is often useful.")
parser.add_argument('--random-starts',
                    type=int,
                    help="The number of random starts to use when trying to find "
                         "the MAP estimate for the hyperparameters. If you are "
                         "getting bad fits, try increasing this. If not "
                         "specified, this is set to the number of processors "
                         "available on your machine.")
parser.add_argument('--upper-factor',
                    type=float,
                    default=5,
                    help="Factor by which the range of the data is multiplied "
                         "to generate the upper bound on the hyperparameters. If "
                         "you are getting bad fits, try adjusting this.")
parser.add_argument('--lower-factor',
                    type=float,
                    default=5,
                    help="Factor by which the range of the data is divided to "
                         "generate the lower bound on the hyperparameters. If "
                         "you are getting bad fits, try adjusting this.")
parser.add_argument('--bounds',
                    type=float,
                    nargs='+',
                    help="Bounds to use for each of the hyperparameters. "
                         "Specified as pairs of lower, upper bounds. If present, "
                         "there should be two such pairs for the squared "
                         "exponential kernel and five such pairs for the Gibbs "
                         "kernel with tanh length scale warping. If not specified, "
                         "somewhat intelligent guesses are made based on the data "
                         "itself. If you are getting bad fits, try tweaking these. "
                         "Note that this overrides --upper-factor and --lower-factor "
                         "if present.")
parser.add_argument('--use-MCMC',
                    action='store_true',
                    help="Set this flag to use MCMC integration over the "
                         "hyperparameters instead of MAP estimation. This is "
                         "the most rigorous way of capturing all uncertainty, "
                         "and should always be used if you are interested in "
                         "gradients and/or the details of the edge. Note that "
                         "this is very computationally expensive, but benefits "
                         "strongly from having many cores to run on.")
parser.add_argument('--walkers',
                    type=int,
                    default=200,
                    help="The number of walkers to use to explore the parameter "
                         "space. This number should be high, on the order of "
                         "a few hundred. If you are getting poor mixing of the "
                         "MCMC integration, try increasing this by a hundred at "
                         "a time.")
parser.add_argument('--MCMC-samp',
                    type=int,
                    default=500,
                    help="The number of samples to take with each walker.")
parser.add_argument('--burn',
                    type=int,
                    default=100,
                    help="The number of samples to discard at the start of each "
                         "MCMC chain. This will usually need to be on the order "
                         "of a few hundred. If your chains are taking too long "
                         "to mix, try narrowing the bounds on the hyperparameters.")
parser.add_argument('--keep',
                    type=int,
                    default=200,
                    help="The number of MCMC samples to keep when fitting the "
                         "profiles. This lets you get a full picture of the "
                         "parameter space but only fit on the number of profiles "
                         "needed.")
parser.add_argument('--full-monte-carlo',
                    action='store_true',
                    help="Set this flag to compute these mean samples using a "
                         "full Monte Carlo simulation instead of error propagation.")
parser.add_argument('--monte-carlo-samples',
                    type=int,
                    default=500,
                    help="The number of Monte Carlo samples to use when "
                         "--full-monte-carlo is set and MAP estimation is used.")
parser.add_argument('--reject-negative',
                    action='store_true',
                    help="Set this flag to reject any Monte Carlo samples that go "
                         "negative during the full Monte Carlo simulation. Only "
                         "has an effect if --full-monte-carlo is set.")
parser.add_argument('--reject-non-monotonic',
                    action='store_true',
                    help="Set this flag to reject any Monte Carlo samples that "
                         "are not monotonic when performing the full Monte Carlo "
                         "simulation. Only has an effect if --full-monte-carlo "
                         "is set.")
parser.add_argument('--no-a-over-L',
                    action='store_true',
                    help="Set this flag to turn off the computation of a/L, "
                         "which can save some time if you don't need gradients/"
                         "scale lengths.")
parser.add_argument('--compute-vol-avg',
                    action='store_true',
                    help="Set this flag to compute the volume average of the "
                         "profile.")
parser.add_argument('--compute-peaking',
                    action='store_true',
                    help="Set this flag to compute the peaking figure of merit "
                         "of the profile.")
parser.add_argument('-i', '--input-filename',
                    help="Filename/path to a CSV or NetCDF file containing the "
                         "profile data to be fit. Note that if you wish to make "
                         "use of the core/edge value, slope constraints you must "
                         "provide t-min and t-max bracketing the times used so "
                         "that the program can find the locations of the magnetic "
                         "axis and GH limiter in the relevant coordinates. "
                         "(Though it will always be able to find the magnetic "
                         "axis if you use a normalized coordinate.) If the "
                         "extension of the file is .csv it will be treated as a "
                         "comma-separated values file, all other extensions will "
                         "be treated as NetCDF files. If using a CSV file, the "
                         "first row should be a comma-separated list of the field "
                         "names, as defined with --abscissa-name and "
                         "--ordinate-name. These columns can be in any order in "
                         "the actual file.")
parser.add_argument('-o', '--output-filename',
                    help="Filename/path to write a NetCDF or CSV file to"
                         "containing the results of the fit. If not specified, "
                         "you will be prompted for a filename upon completing "
                         "the fit.")
parser.add_argument('-x', '--abscissa-name',
                    nargs='+',
                    help="Name(s) of the variable(s) in the input/output NetCDF/"
                         "CSV files that contain the values of the abscissa "
                         "(independent variable(s)). The uncertainty in the "
                         "abscissa must then be in err_ABSCISSA_NAME, if "
                         "present. Note that uncertainties in the abscissa are "
                         "NOT used in the profile fit at present, but will be "
                         "shown on the plot. If you do not provide this when "
                         "using a CSV file, the names will automatically be "
                         "inferred by looking at the order of the header of the "
                         "CSV file. This argument is required when using a "
                         "NetCDF file. You must always put your time variable "
                         "first for this to work properly.")
parser.add_argument('-y', '--ordinate-name',
                    help="Name of the variable in the input/output NetCDF/CSV "
                         "files that contains the values of the ordinate "
                         "(dependent variable). The uncertainty in the ordinate "
                         "must then be in err_ORDINATE_NAME. If you do not "
                         "provide this when using a CSV file, the names will "
                         "automatically be inferred by looking at the order of "
                         "the header of the CSV file. This argument is required "
                         "when using a NetCDF file.")
parser.add_argument('--metadata-lines',
                    type=int,
                    help="Number of lines of metadata at the start of your CSV "
                         "file to read. You can include the shot, times and "
                         "coordinate in the CSV file itself in this manner. See "
                         "the documentation on profiletools.CMod.read_plasma_csv "
                         "for more details. If you leave this blank, the program "
                         "will check to see if the first line of your file is of "
                         "the form 'metadata LINES', where LINES is the number of "
                         "lines of metadata present.")
parser.add_argument('--full-auto',
                    action='store_true',
                    help="Set this flag to disable all prompting for missing/"
                         "optional arguments and run fully automatically. The "
                         "program will exit with status 1 if any required "
                         "parameters are missing. The program will still stop to "
                         "allow the user to assess the quality of the fit.")
parser.add_argument('--no-interaction',
                    action='store_true',
                    help="Set this flag to not let the user interact with the "
                         "GUI. The fit will be automatically run and saved, "
                         "along with a picture of the plot, to the output file "
                         "specified.")

args = parser.parse_args()

# Set up the GUI:
import sys
import socket
# Hackishly augment the path for now:
if 'juggernaut' not in socket.gethostname().lower():
    sys.path.append("/home/markchil/codes/gptools")
    sys.path.append("/home/markchil/codes/profiletools")
    sys.path.append("/home/markchil/codes/efit/development/EqTools")

import matplotlib
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2TkAgg
from matplotlib.backend_bases import key_press_handler
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
import matplotlib.gridspec as mplgs
import Tkinter as tk
import tkFileDialog
import tkFont
import ttk
import collections
import time
import multiprocessing
import profiletools
import gptools
import eqtools
import MDSplus
import os.path
import copy
import re
import scipy
import scipy.io
import numpy
import numpy.linalg
import itertools
import getpass
import inspect
import csv

DATE_FORMAT = '%d %b %Y %H:%M:%S'

class TreeFileFrame(tk.Frame):
    TREE_MODE = 1
    FILE_MODE = 2
    
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create radio buttons to select tree versus file:
        self.source_state = tk.IntVar(self)
        self.tree_button = tk.Radiobutton(self,
                                          text="tree",
                                          variable=self.source_state,
                                          value=self.TREE_MODE,
                                          command=self.master.update_source)
        self.file_button = tk.Radiobutton(self,
                                          text="file:",
                                          variable=self.source_state,
                                          value=self.FILE_MODE,
                                          command=self.master.update_source)
        self.tree_button.grid(row=0, column=0)
        self.file_button.grid(row=0, column=1)
    
        # Create text entry to input file path:
        self.path_entry = tk.Entry(self)
        self.path_entry.grid(row=0, column=2, stick=tk.E + tk.W)
    
        # Create button to select file:
        self.choose_file_button = tk.Button(self,
                                            text="choose file",
                                            command=self.choose_file)
        self.choose_file_button.grid(row=0, column=3)
        
        # Set file path entry to expand:
        self.grid_columnconfigure(2, weight=1)
    
    def choose_file(self):
        filepath = tkFileDialog.askopenfilename()
        if filepath:
            self.path_entry.delete(0, tk.END)
            self.path_entry.insert(0, filepath)

class VariableNameFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create label for variables:
        self.variables_master_label = tk.Label(self, text="variable/column names:")
        self.variables_master_label.grid(row=0, column=0, columnspan=6, sticky=tk.W)
        
        # Create label for time:
        self.time_label = tk.Label(self, text="time:")
        self.time_label.grid(row=1, column=0, sticky=tk.E)
        
        # Create box for time:
        self.time_box = tk.Entry(self, width=4)
        self.time_box.grid(row=1, column=1, sticky='EW')
        
        # Create label for space:
        self.space_label = tk.Label(self, text="space:")
        self.space_label.grid(row=1, column=2, sticky=tk.E)
        
        # Create box for space:
        self.space_box = tk.Entry(self, width=4)
        self.space_box.grid(row=1, column=3, sticky='EW')
        
        # Create label for data:
        self.data_label = tk.Label(self, text="data:")
        self.data_label.grid(row=1, column=4, sticky=tk.E)
        
        # Create box for data:
        self.data_box = tk.Entry(self, width=4)
        self.data_box.grid(row=1, column=5, sticky='EW')
        
        # Create label and box for number of metadata lines:
        self.meta_label = tk.Label(self, text="metadata:")
        self.meta_label.grid(row=1, column=6, sticky='E')
        self.meta_box = tk.Entry(self, width=4)
        self.meta_box.grid(row=1, column=7, sticky='EW')
        
        # Configure boxes to grow:
        self.grid_columnconfigure(1, weight=1)
        self.grid_columnconfigure(3, weight=1)
        self.grid_columnconfigure(5, weight=1)
        self.grid_columnconfigure(7, weight=1)

class ShotFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create label for shot:
        self.shot_label = tk.Label(self, text="shot:")
        self.shot_label.grid(row=0, column=0)
        
        # Create box for shot:
        self.shot_box = tk.Entry(self)
        self.shot_box.grid(row=0, column=1, sticky=tk.E + tk.W)
        
        # Allow shot entry to expand to fill:
        self.grid_columnconfigure(1, weight=1)

class SignalCoordinateFrame(tk.Frame):
    SIGNAL_OPTIONS = ['ne', 'Te']
    COORDINATE_OPTIONS = ['psinorm', 'Rmid', 'r/a', 'volnorm', 'phinorm',
                          'sqrtpsinorm', 'sqrtr/a', 'sqrtvolnorm', 'sqrtphinorm']
    
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create label for signal:
        self.signal_label = tk.Label(self, text="signal:")
        self.signal_label.grid(row=0, column=0, sticky='E')
        
        # Create option menu for signal:
        self.signal_var = tk.StringVar(self)
        self.signal_var.set(self.SIGNAL_OPTIONS[0])
        self.signal_menu = tk.OptionMenu(self, self.signal_var, *self.SIGNAL_OPTIONS, command=self.master.update_signal)
        self.signal_menu.grid(row=0, column=1, sticky='EW')
        
        # Create label for coordinate:
        self.coordinate_label = tk.Label(self, text="coordinate:")
        self.coordinate_label.grid(row=0, column=2, sticky='E')
        
        # Create option menu for coordinate:
        self.coordinate_var = tk.StringVar(self)
        self.coordinate_var.set(self.COORDINATE_OPTIONS[0])
        self.coordinate_menu = tk.OptionMenu(self, self.coordinate_var, *self.COORDINATE_OPTIONS)
        self.coordinate_menu.grid(row=0, column=3, sticky='EW')
        
        # Let menus expand:
        # self.grid_columnconfigure(1, weight=1)
        # self.grid_columnconfigure(3, weight=1)

class OptionBox(tk.Frame):
    def __init__(self, system, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        self.system = system
        
        self.state_var = tk.IntVar(self)
        
        self.button = tk.Checkbutton(self, text=self.system, variable=self.state_var)
        self.button.grid(row=0, column=0)
        
        # Set default value:
        self.button.select()

class SystemFrame(tk.Frame):
    SYSTEM_OPTIONS = {'Te': ['CTS', 'ETS', 'GPC', 'GPC2', 'FRCECE'],
                      'ne': ['CTS', 'ETS']}
    
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        self.signal = None
        self.buttons = []
        self.update_systems(self.master.signal_coordinate_frame.signal_var.get())
    
    def update_systems(self, signal):
        if signal != self.signal:
            self.signal = signal
            for b in self.buttons:
                b.destroy()
            self.buttons = [OptionBox(sys, self) for sys in self.SYSTEM_OPTIONS[signal]]
            for k in xrange(0, len(self.buttons)):
                self.buttons[k].grid(row=0, column=k)

class DataSourceFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create main label for frame:
        self.frame_label = tk.Label(self, text="Data Source", font=tkFont.Font(weight=tkFont.BOLD))
        self.frame_label.grid(row=0, sticky='W')
        
        # Create frame to hold tree/file selector row:
        self.tree_file_frame = TreeFileFrame(self)
        self.tree_file_frame.grid(row=1, sticky='EW')
        
        # Create frame to hold variable name selector row:
        self.variable_name_frame = VariableNameFrame(self)
        self.variable_name_frame.grid(row=2, sticky='EW')
        
        # Create frame to hold shot selector row:
        self.shot_frame = ShotFrame(self)
        self.shot_frame.grid(row=3, sticky='EW')
        
        # Create frame to hold signal/coordinate selection menus:
        self.signal_coordinate_frame = SignalCoordinateFrame(self)
        self.signal_coordinate_frame.grid(row=4, sticky='EW')
        
        # Create frame to hold signal selection check buttons:
        self.system_frame = SystemFrame(self)
        self.system_frame.grid(row=5, sticky='W')
        
        # Allow columns to grow:
        self.grid_columnconfigure(0, weight=1)
        
        # Set default conditions:
        self.tree_file_frame.tree_button.invoke()
    
    def update_source(self):
        if self.tree_file_frame.source_state.get() == self.tree_file_frame.TREE_MODE:
            self.tree_file_frame.path_entry.config(state=tk.DISABLED)
            self.tree_file_frame.choose_file_button.config(state=tk.DISABLED)
            for w in self.variable_name_frame.winfo_children():
                w.config(state=tk.DISABLED)
            self.signal_coordinate_frame.signal_label.config(state=tk.NORMAL)
            self.signal_coordinate_frame.signal_menu.config(state=tk.NORMAL)
            for b in self.system_frame.buttons:
                b.button.config(state=tk.NORMAL)
        elif self.tree_file_frame.source_state.get() == self.tree_file_frame.FILE_MODE:
            self.tree_file_frame.path_entry.config(state=tk.NORMAL)
            self.tree_file_frame.choose_file_button.config(state=tk.NORMAL)
            for w in self.variable_name_frame.winfo_children():
                w.config(state=tk.NORMAL)
            self.signal_coordinate_frame.signal_label.config(state=tk.DISABLED)
            self.signal_coordinate_frame.signal_menu.config(state=tk.DISABLED)
            for b in self.system_frame.buttons:
                b.button.config(state=tk.DISABLED)
    
    def update_signal(self, signal):
        self.system_frame.update_systems(signal)

class TimeWindowFrame(tk.Frame):
    WINDOW_MODE = 1
    POINT_MODE = 2
    
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create radio buttons to select between window and points:
        self.method_state = tk.IntVar(self)
        self.window_button = tk.Radiobutton(self,
                                            text="time window:",
                                            variable=self.method_state,
                                            value=self.WINDOW_MODE,
                                            command=self.update_method)
        self.point_button = tk.Radiobutton(self,
                                           text="time points:",
                                           variable=self.method_state,
                                           value=self.POINT_MODE,
                                           command=self.update_method)
        self.window_button.grid(row=0, column=0, sticky='W')
        self.point_button.grid(row=1, column=0, sticky='W')
        
        # Create labels and fields to hold time window:
        self.t_min_box = tk.Entry(self, width=6)
        self.t_min_box.grid(row=0, column=1, sticky='EW')
        self.t_max_box = tk.Entry(self, width=6)
        self.t_max_box.grid(row=0, column=3, sticky='EW')
        self.t_min_units = tk.Label(self, text="s to")
        self.t_min_units.grid(row=0, column=2)
        self.t_max_units = tk.Label(self, text="s")
        self.t_max_units.grid(row=0, column=4)
        
        # Create labels and fields to hold time points:
        self.times_box = tk.Entry(self)
        self.times_box.grid(row=1, column=1, columnspan=4, sticky='EW')
        
        # Allow elements to resize:
        self.grid_columnconfigure(1, weight=1)
        self.grid_columnconfigure(3, weight=1)
    
    def update_method(self):
        if self.method_state.get() == self.WINDOW_MODE:
            self.times_box.config(state=tk.DISABLED)
            self.t_min_box.config(state=tk.NORMAL)
            self.t_min_units.config(state=tk.NORMAL)
            self.t_max_box.config(state=tk.NORMAL)
            self.t_max_units.config(state=tk.NORMAL)
        else:
            self.times_box.config(state=tk.NORMAL)
            self.t_min_box.config(state=tk.DISABLED)
            self.t_min_units.config(state=tk.DISABLED)
            self.t_max_box.config(state=tk.DISABLED)
            self.t_max_units.config(state=tk.DISABLED)

class MethodFrame(tk.Frame):
    METHOD_OPTIONS = ['conventional', 'robust', 'all points']
    ERROR_METHOD_OPTIONS = ['sample', 'RMS', 'total']
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create label for method:
        self.method_label = tk.Label(self, text="averaging method:")
        self.method_label.grid(row=0, column=0, sticky='E')
        
        # Create option menu for methods:
        self.method_var = tk.StringVar(self)
        self.method_var.set(self.METHOD_OPTIONS[0])
        self.method_menu = tk.OptionMenu(self, self.method_var, *self.METHOD_OPTIONS, command=self.update_method)
        self.method_menu.grid(row=0, column=1, sticky='W')
        
        # Create label for error method:
        self.error_method_label = tk.Label(self, text="uncertainty method:")
        self.error_method_label.grid(row=1, column=0, sticky='E')
        
        # Create option menu for error methods:
        self.error_method_var = tk.StringVar(self)
        self.error_method_var.set(self.ERROR_METHOD_OPTIONS[0])
        self.error_method_menu = tk.OptionMenu(self, self.error_method_var, *self.ERROR_METHOD_OPTIONS)
        self.error_method_menu.grid(row=1, column=1, sticky='W')
    
    def update_method(self, new_meth):
        if new_meth == 'all points':
            self.error_method_menu.config(state=tk.DISABLED)
            self.error_method_label.config(state=tk.DISABLED)
        else:
            self.error_method_menu.config(state=tk.NORMAL)
            self.error_method_label.config(state=tk.NORMAL)

class AveragingFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create main label for frame:
        self.frame_label = tk.Label(self, text="Time Points/Averaging", font=tkFont.Font(weight=tkFont.BOLD))
        self.frame_label.grid(row=0, sticky='W')
        
        # Create frame to hold time window selection:
        self.time_window_frame = TimeWindowFrame(self)
        self.time_window_frame.grid(row=1, sticky='EW')
        
        # Create frame to hold averaging selection:
        self.method_frame = MethodFrame(self)
        self.method_frame.grid(row=2, sticky='W')
        
        # Allow elements to resize:
        self.grid_columnconfigure(0, weight=1)
        
        # Set default conditions:
        self.time_window_frame.window_button.invoke()

class OutlierFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create main label for frame:
        self.frame_label = tk.Label(self, text="Outlier Rejection", font=tkFont.Font(weight=tkFont.BOLD))
        self.frame_label.grid(row=0, sticky='W')
        
        # Create checkbuttons to select types:
        self.extreme_state = tk.IntVar(self)
        self.extreme_button = tk.Checkbutton(self,
                                             text="extreme change",
                                             variable=self.extreme_state,
                                             command=self.update_extreme)
        self.extreme_button.grid(row=1, column=0, sticky='W')
        self.outlier_state = tk.IntVar(self)
        self.outlier_button = tk.Checkbutton(self,
                                             text="distance from fit",
                                             variable=self.outlier_state,
                                             command=self.update_outlier)
        self.outlier_button.grid(row=2, column=0, sticky='W')
        
        # Create boxes and labels to specify thresholds:
        self.extreme_thresh_label = tk.Label(self, text="threshold:")
        self.extreme_thresh_label.grid(row=1, column=1)
        self.extreme_thresh_box = tk.Entry(self, width=6)
        self.extreme_thresh_box.insert(tk.END, '9')
        self.extreme_thresh_box.grid(row=1, column=2, sticky='EW')
        self.extreme_thresh_unit_label = tk.Label(self, text=u"\u03C3")
        self.extreme_thresh_unit_label.grid(row=1, column=3, sticky='W')
        
        self.outlier_thresh_label = tk.Label(self, text="threshold:")
        self.outlier_thresh_label.grid(row=2, column=1)
        self.outlier_thresh_box = tk.Entry(self, width=6)
        self.outlier_thresh_box.insert(tk.END, '3')
        self.outlier_thresh_box.grid(row=2, column=2, sticky='EW')
        self.outlier_thresh_unit_label = tk.Label(self, text=u"\u03C3")
        self.outlier_thresh_unit_label.grid(row=2, column=3, sticky='W')
        
        self.update_extreme()
        self.update_outlier()
    
    def update_extreme(self):
        if self.extreme_state.get():
            self.extreme_thresh_label.config(state=tk.NORMAL)
            self.extreme_thresh_box.config(state=tk.NORMAL)
            self.extreme_thresh_unit_label.config(state=tk.NORMAL)
        else:
            self.extreme_thresh_label.config(state=tk.DISABLED)
            self.extreme_thresh_box.config(state=tk.DISABLED)
            self.extreme_thresh_unit_label.config(state=tk.DISABLED)
    
    def update_outlier(self):
        if self.outlier_state.get():
            self.outlier_thresh_label.config(state=tk.NORMAL)
            self.outlier_thresh_box.config(state=tk.NORMAL)
            self.outlier_thresh_unit_label.config(state=tk.NORMAL)
        else:
            self.outlier_thresh_label.config(state=tk.DISABLED)
            self.outlier_thresh_box.config(state=tk.DISABLED)
            self.outlier_thresh_unit_label.config(state=tk.DISABLED)

HYPERPARAMETERS = collections.OrderedDict([
    ('gibbstanh', collections.OrderedDict([(u"\u03C3f", "signal variance"),
                                          (u"\u21131", "core covariance length scale"),
                                          (u"\u21132", "edge covariance length scale"),
                                          (u"\u2113w", "core/edge transition width"),
                                          (u"x0", "core/edge transition location")])),
    ('SE', collections.OrderedDict([(u"\u03C3f", "signal variance"),
                                   (u"\u2113", "covariance length scale")])),
])

class KernelTypeFrame(tk.Frame):    
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create label for type:
        self.k_label = tk.Label(self, text="kernel type:")
        self.k_label.grid(row=0, column=0, sticky='E')
        
        # Create option menu for type:
        self.k_var = tk.StringVar(self)
        self.k_var.set(HYPERPARAMETERS.keys()[0])
        self.k_menu = tk.OptionMenu(self, self.k_var, *HYPERPARAMETERS.keys(), command=self.master.update_kernel)
        self.k_menu.grid(row=0, column=1, sticky='W')
        
        # Create check button to select only core data:
        self.core_only_state = tk.IntVar(self)
        self.core_only_button = tk.Checkbutton(self,
                                               text="core only",
                                               variable=self.core_only_state)
        self.core_only_button.grid(row=0, column=2, sticky='W')

class KernelBoundsFrame(tk.Frame):    
    def __init__(self, hyperparameters, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        self.hyperparameters = hyperparameters
        
        self.labels = []
        self.lower_bounds = []
        self.to_labels = []
        self.upper_bounds = []
        
        for k, hp in zip(xrange(0, len(self.hyperparameters)), self.hyperparameters):
            self.labels.append(tk.Label(self,
                                        text="%s, %s:" % (self.hyperparameters[hp], hp,)))
            self.lower_bounds.append(tk.Entry(self, width=6))
            self.to_labels.append(tk.Label(self, text="to"))
            self.upper_bounds.append(tk.Entry(self, width=6))
            
            self.labels[k].grid(row=k, column=0, sticky='E')
            self.lower_bounds[k].grid(row=k, column=1, sticky='EW')
            self.to_labels[k].grid(row=k, column=2)
            self.upper_bounds[k].grid(row=k, column=3, sticky='EW')
        
        self.grid_columnconfigure(1, weight=1)
        self.grid_columnconfigure(3, weight=1)

class ConstraintsFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Checkbox for core constraint:
        self.core_state = tk.IntVar(self)
        self.core_button = tk.Checkbutton(self,
                                          text="core constraint",
                                          variable=self.core_state,
                                          command=self.update_core)
        self.core_button.grid(row=0, column=0, sticky='W')
        
        # Checkbox for edge constraint:
        self.edge_state = tk.IntVar(self)
        self.edge_button = tk.Checkbutton(self,
                                          text="edge constraint",
                                          variable=self.edge_state,
                                          command=self.update_edge)
        self.edge_button.grid(row=1, column=0, sticky='W')
        
        # Label for core location:
        self.core_label = tk.Label(self, text="location:")
        self.core_label.grid(row=0, column=1, sticky='E')
        
        # Label for edge locations:
        self.edge_label = tk.Label(self, text="locations:")
        self.edge_label.grid(row=1, column=1, sticky='E')
        
        # Box for core location:
        self.core_loc = tk.Entry(self)
        self.core_loc.grid(row=0, column=2, sticky='EW')
        
        # Box for edge location:
        self.edge_loc = tk.Entry(self)
        self.edge_loc.grid(row=1, column=2, sticky='EW')
        
        # Allow boxes to expand:
        self.grid_columnconfigure(2, weight=1)
    
    def update_core(self):
        if self.core_state.get():
            self.core_label.config(state=tk.NORMAL)
            self.core_loc.config(state=tk.NORMAL)
        else:
            self.core_label.config(state=tk.DISABLED)
            self.core_loc.config(state=tk.DISABLED)
    
    def update_edge(self):
        if self.edge_state.get():
            self.edge_label.config(state=tk.NORMAL)
            self.edge_loc.config(state=tk.NORMAL)
        else:
            self.edge_label.config(state=tk.DISABLED)
            self.edge_loc.config(state=tk.DISABLED)

class KernelFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create main label for frame:
        self.frame_label = tk.Label(self, text="Covariance Kernel", font=tkFont.Font(weight=tkFont.BOLD))
        self.frame_label.grid(row=0, sticky='W')
        
        # Create frame to hold kernel type:
        self.kernel_type_frame = KernelTypeFrame(self)
        self.kernel_type_frame.grid(row=1, sticky='W')
        self.k = self.kernel_type_frame.k_var.get()
        
        # Create frame to hold hyperparameter bounds:
        self.bounds_label = tk.Label(self, text="hyperparameter bounds:")
        self.bounds_label.grid(row=2, sticky='W')
        self.bounds_frame = KernelBoundsFrame(HYPERPARAMETERS[self.kernel_type_frame.k_var.get()], self)
        self.bounds_frame.grid(row=3, sticky='EW')
        
        # Create frame to hold constraint checkboxes:
        self.constraints_frame = ConstraintsFrame(self)
        self.constraints_frame.grid(row=4, sticky='EW')
        
        # Allow boxes to expand:
        self.grid_columnconfigure(0, weight=1)
        
        # Initial settings:
        self.constraints_frame.core_button.invoke()
        self.constraints_frame.edge_button.invoke()
    
    def update_kernel(self, k):
        if k != self.k:
            self.bounds_frame.destroy()
            self.bounds_frame = KernelBoundsFrame(HYPERPARAMETERS[k], self)
            self.bounds_frame.grid(row=3, sticky='EW')
            self.k = k

class FittingMethodFrame(tk.Frame):
    USE_MAP = 1
    USE_MCMC = 2
    
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create radio buttons to select MAP versus MCMC:
        self.method_state = tk.IntVar(self)
        self.MAP_button = tk.Radiobutton(self,
                                         text="MAP",
                                         variable=self.method_state,
                                         value=self.USE_MAP,
                                         command=self.master.update_method)
        self.MCMC_button = tk.Radiobutton(self,
                                          text="MCMC",
                                          variable=self.method_state,
                                          value=self.USE_MCMC,
                                          command=self.master.update_method)
        self.MAP_button.grid(row=0, column=0)
        self.MCMC_button.grid(row=0, column=3)
        
        # Create label and box to set number of random starts:
        self.starts_label = tk.Label(self, text="random starts:")
        self.starts_label.grid(row=0, column=1, sticky='E')
        self.starts_box = tk.Entry(self, width=6)
        self.starts_box.grid(row=0, column=2, sticky='EW')

class MCMCFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        self.walker_label = tk.Label(self, text="walkers:")
        self.walker_label.grid(row=0, column=0, sticky='E')
        self.walker_box = tk.Entry(self, width=4)
        self.walker_box.insert(tk.END, '200')
        self.walker_box.grid(row=0, column=1, sticky='EW')
        
        self.sample_label = tk.Label(self, text="samples:")
        self.sample_label.grid(row=0, column=2, sticky='E')
        self.sample_box = tk.Entry(self, width=4)
        self.sample_box.insert(tk.END, '500')
        self.sample_box.grid(row=0, column=3, sticky='EW')
        
        self.burn_label = tk.Label(self, text="burn:")
        self.burn_label.grid(row=0, column=4, sticky='E')
        self.burn_box = tk.Entry(self, width=4)
        self.burn_box.insert(tk.END, '100')
        self.burn_box.grid(row=0, column=5, sticky='EW')
        
        self.keep_label = tk.Label(self, text="keep:")
        self.keep_label.grid(row=0, column=6, sticky='E')
        self.keep_box = tk.Entry(self, width=4)
        self.keep_box.insert(tk.END, '200')
        self.keep_box.grid(row=0, column=7, sticky='EW')
        
        self.grid_columnconfigure(1, weight=1)
        self.grid_columnconfigure(3, weight=1)
        self.grid_columnconfigure(5, weight=1)
        self.grid_columnconfigure(7, weight=1)

class MCMCConstraintFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        self.full_MC_state = tk.IntVar(self)
        self.full_MC_button = tk.Checkbutton(self,
                                             text="use full Monte Carlo",
                                             variable=self.full_MC_state,
                                             command=self.update_full_MC)
        self.full_MC_button.grid(row=0, column=0, sticky='W')
        
        self.samples_label = tk.Label(self, text="samples:")
        self.samples_label.grid(row=0, column=1, sticky='E')
        
        self.samples_box = tk.Entry(self, width=4)
        self.samples_box.grid(row=0, column=2, sticky='EW')
        
        self.pos_state = tk.IntVar(self)
        self.pos_button = tk.Checkbutton(self,
                                         text="reject negative samples",
                                         variable=self.pos_state)
        self.pos_button.grid(row=1, column=0, sticky='W')
        
        self.mono_state = tk.IntVar(self)
        self.mono_button = tk.Checkbutton(self,
                                          text="reject non-monotonic samples",
                                          variable=self.mono_state)
        self.mono_button.grid(row=2, column=0, sticky='W')
        
        self.grid_columnconfigure(2, weight=1)
            
    def update_full_MC(self):
        if self.full_MC_state.get():
            self.pos_button.config(state=tk.NORMAL)
            if self.master.master.master.eval_frame.a_L_state.get():
                self.mono_button.config(state=tk.NORMAL)
            if self.master.method_frame.method_state.get() == self.master.method_frame.USE_MAP:
                self.samples_label.config(state=tk.NORMAL)
                self.samples_box.config(state=tk.NORMAL)
            else:
                self.samples_label.config(state=tk.DISABLED)
                self.samples_box.config(state=tk.DISABLED)
        else:
            self.samples_label.config(state=tk.DISABLED)
            self.samples_box.config(state=tk.DISABLED)
            self.pos_button.config(state=tk.DISABLED)
            self.mono_button.config(state=tk.DISABLED)

class FittingFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create main label for frame:
        self.frame_label = tk.Label(self, text="Fitting Method", font=tkFont.Font(weight=tkFont.BOLD))
        self.frame_label.grid(row=0, sticky='W')
        
        # Create frame to hold fitting method selection:
        self.method_frame = FittingMethodFrame(self)
        self.method_frame.grid(row=1, sticky='W')
        
        # Create frame to hold MCMC parameters:
        self.MCMC_frame = MCMCFrame(self)
        self.MCMC_frame.grid(row=2, sticky='EW')
        
        # Create frame to hold MCMC constraint options:
        self.MCMC_constraint_frame = MCMCConstraintFrame(self)
        self.MCMC_constraint_frame.grid(row=3, sticky='EW')
        
        self.grid_columnconfigure(0, weight=1)
        
        self.method_frame.MAP_button.invoke()
        self.MCMC_constraint_frame.update_full_MC()
    
    def update_method(self):
        self.MCMC_constraint_frame.update_full_MC()
        if self.method_frame.method_state.get() == self.method_frame.USE_MAP:
            self.method_frame.starts_label.config(state=tk.NORMAL)
            self.method_frame.starts_box.config(state=tk.NORMAL)
            for w in self.MCMC_frame.winfo_children():
                w.config(state=tk.DISABLED)
        else:
            self.method_frame.starts_label.config(state=tk.DISABLED)
            self.method_frame.starts_box.config(state=tk.DISABLED)
            for w in self.MCMC_frame.winfo_children():
                w.config(state=tk.NORMAL)

class EvaluationFrame(tk.Frame):
    UNIFORM_GRID = 1
    POINTS = 2
    
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create main label for frame:
        self.frame_label = tk.Label(self, text="Evaluation", font=tkFont.Font(weight=tkFont.BOLD))
        self.frame_label.grid(row=0, sticky='W')
        
        # Create radio buttons for uniform grid versus specific points:
        self.method_state = tk.IntVar(self)
        self.uniform_button = tk.Radiobutton(self,
                                             text="uniform grid:",
                                             variable=self.method_state,
                                             value=self.UNIFORM_GRID,
                                             command=self.update_method)
        self.points_button = tk.Radiobutton(self,
                                            text="specific points:",
                                            variable=self.method_state,
                                            value=self.POINTS,
                                            command=self.update_method)
        self.uniform_button.grid(row=1, column=0, sticky='W')
        self.points_button.grid(row=2, column=0, sticky='W')
        
        # Create labels and boxes for setting parameters:
        self.npts_box = tk.Entry(self, width=4)
        self.npts_box.grid(row=1, column=1, sticky='EW')
        self.npts_label = tk.Label(self, text="points from")
        self.npts_label.grid(row=1, column=2)
        self.x_min_box = tk.Entry(self, width=4)
        self.x_min_box.grid(row=1, column=3, sticky='EW')
        self.to_label = tk.Label(self, text="to")
        self.to_label.grid(row=1, column=4)
        self.x_max_box = tk.Entry(self, width=4)
        self.x_max_box.grid(row=1, column=5, sticky='EW')
        
        self.x_points_box = tk.Entry(self)
        self.x_points_box.grid(row=2, column=1, columnspan=5, sticky='EW')
        
        # Create frame to hold options of things to evaluate:
        self.eval_option_frame = tk.Frame(self)
        
        # Create label for compute options:
        self.compute_label = tk.Label(self.eval_option_frame, text="compute:")
        self.compute_label.grid(row=0, column=0, sticky='E')
        
        # Create checkbox to select whether or not a/L is computed:
        self.a_L_state = tk.IntVar(self)
        self.a_L_button = tk.Checkbutton(self.eval_option_frame,
                                         text="a/L",
                                         variable=self.a_L_state,
                                         command=self.update_a_L)
        self.a_L_button.grid(row=0, column=1, sticky='W')
        
        # Create checkbox to select whether or not volume average is computed:
        self.vol_avg_state = tk.IntVar(self)
        self.vol_avg_button = tk.Checkbutton(self.eval_option_frame,
                                             text="volume average",
                                             variable=self.vol_avg_state)
        self.vol_avg_button.grid(row=0, column=2, sticky='W')
        
        # Create checkbox to select whether or not peaking is computed:
        self.peaking_state = tk.IntVar(self)
        self.peaking_button = tk.Checkbutton(self.eval_option_frame,
                                             text="peaking",
                                             variable=self.peaking_state)
        self.peaking_button.grid(row=0, column=3, sticky='W')
        
        self.eval_option_frame.grid(row=3, column=0, sticky='W', columnspan=6)
        
        self.grid_columnconfigure(1, weight=1)
        self.grid_columnconfigure(3, weight=1)
        self.grid_columnconfigure(5, weight=1)
        
        self.uniform_button.invoke()
        self.a_L_button.select()
    
    def update_method(self):
        if self.method_state.get() == self.UNIFORM_GRID:
            self.npts_box.config(state=tk.NORMAL)
            self.npts_label.config(state=tk.NORMAL)
            self.x_min_box.config(state=tk.NORMAL)
            self.to_label.config(state=tk.NORMAL)
            self.x_max_box.config(state=tk.NORMAL)
            self.x_points_box.config(state=tk.DISABLED)
        else:
            self.npts_box.config(state=tk.DISABLED)
            self.npts_label.config(state=tk.DISABLED)
            self.x_min_box.config(state=tk.DISABLED)
            self.to_label.config(state=tk.DISABLED)
            self.x_max_box.config(state=tk.DISABLED)
            self.x_points_box.config(state=tk.NORMAL)
    
    def update_a_L(self):
        if not self.a_L_state.get():
            self.master.master.master.plot_frame.a_grad.set_visible(False)
            self.master.master.master.plot_frame.a_a_L.set_visible(False)
            self.master.master.master.plot_frame.a_val.change_geometry(1, 1, 1)
            # plt.setp(self.master.master.master.plot_frame.a_val.get_xticklabels(), visible=True)
        else:
            self.master.master.master.plot_frame.a_val.change_geometry(3, 1, 1)
            # plt.setp(self.master.master.master.plot_frame.a_val.get_xticklabels(), visible=False)
            self.master.master.master.plot_frame.a_grad.set_visible(True)
            self.master.master.master.plot_frame.a_a_L.set_visible(True)
        self.master.master.master.plot_frame.canvas.draw()
        
        if self.a_L_state.get() and self.master.master.fitting_frame.MCMC_constraint_frame.full_MC_state.get():
            self.master.master.fitting_frame.MCMC_constraint_frame.mono_button.config(state=tk.NORMAL)
        else:
            self.master.master.fitting_frame.MCMC_constraint_frame.mono_button.config(state=tk.DISABLED)

class StatusBox(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create main label for frame:
        # self.frame_label = tk.Label(self, text="Status", font=tkFont.Font(weight=tkFont.BOLD))
        # self.frame_label.grid(row=0, sticky='W')
        
        self.history_box = tk.Text(self,
                                   width=30,
                                   height=6,
                                   # font=tkFont.Font(size=8)
                                  )
        self.history_box.grid(row=1, sticky='EWNS')
        self.add_line(
            'This is fit_profile version {ver}, launched at {time}. {cores} cores detected.' \
            .format(ver=__version__,
                    time=time.strftime(DATE_FORMAT),
                    cores=multiprocessing.cpu_count())
        )
        self.history_scroll = tk.Scrollbar(self)
        self.history_scroll.grid(row=1, column=1, sticky='NS')
        self.history_scroll.config(command=self.history_box.yview)
        self.history_box.config(yscrollcommand=self.history_scroll.set)
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)
        
        self.history_box.bind("<1>", lambda event: self.history_box.focus_set())
    
    def add_line(self, s):
        self.history_box.config(state=tk.NORMAL)
        print(s)
        self.history_box.insert(tk.END, s + '\n')
        self.history_box.config(state=tk.DISABLED)
        self.history_box.yview(tk.END)
        self.history_box.update()

class ControlBox(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        # Create main label for frame:
        # self.frame_label = tk.Label(self, text="Control", font=tkFont.Font(weight=tkFont.BOLD))
        # self.frame_label.grid(row=0, sticky='W')
        
        # Create buttons:
        self.load_button = tk.Button(self, text="load data", command=self.master.master.load_data)
        self.load_button.grid(row=1, column=0)
        self.avg_button = tk.Button(self, text="plot data", command=self.master.master.average_data)
        self.avg_button.grid(row=1, column=1)
        self.fit_button = tk.Button(self, text="fit data", command=self.master.master.fit_data)
        self.fit_button.grid(row=1, column=2)
        self.save_button = tk.Button(self, text="save fit", command=self.master.master.save_fit)
        self.save_button.grid(row=1, column=3)
        self.exit_button = tk.Button(self, text="exit", command=self.master.master.exit)
        self.exit_button.grid(row=1, column=4)

class PlotFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        self.f = Figure()
        self.a_val = self.f.add_subplot(3, 1, 1)
        self.a_grad = self.f.add_subplot(3, 1, 2, sharex=self.a_val)
        self.a_a_L = self.f.add_subplot(3, 1, 3, sharex=self.a_val)
        self.canvas = FigureCanvasTkAgg(self.f, master=self)
        self.canvas.show()
        self.canvas.get_tk_widget().grid(row=0, column=0, sticky='NESW')
        
        self.toolbar_frame = tk.Frame(self)
        self.toolbar = NavigationToolbar2TkAgg(self.canvas, self.toolbar_frame)
        self.toolbar.update()
        # self.canvas._tkcanvas.grid(row=1, column=0, sticky='EW')
        self.toolbar_frame.grid(row=1, column=0, sticky='EW')
        
        self.canvas.mpl_connect('button_press_event', lambda event: self.canvas._tkcanvas.focus_set())
        self.canvas.mpl_connect('key_press_event', self.on_key_event)
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)
        
    def on_key_event(self, evt):
        key_press_handler(evt, self.canvas, self.toolbar)

frame_params = {'relief': tk.RAISED, 'borderwidth': 2}

class ControlFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Frame.__init__(self, *args, **kwargs)
        
        self.note = ttk.Notebook(self)
        
        self.data_time_frame = tk.Frame(self)
        self.fit_eval_frame = tk.Frame(self)
        
        self.data_source_frame = DataSourceFrame(self.data_time_frame, **frame_params)
        self.data_source_frame.grid(row=0, sticky='EW')

        self.averaging_frame = AveragingFrame(self.data_time_frame, **frame_params)
        self.averaging_frame.grid(row=1, sticky='NSEW')

        self.data_time_frame.grid_columnconfigure(0, weight=1)
        self.data_time_frame.grid_rowconfigure(1, weight=1)

        self.kernel_frame = KernelFrame(self, **frame_params)
        # self.kernel_frame.grid(row=0, sticky='EW')

        self.fitting_frame = FittingFrame(self.fit_eval_frame, **frame_params)
        self.fitting_frame.grid(row=0, sticky='EW')

        self.eval_frame = EvaluationFrame(self.fit_eval_frame, **frame_params)
        self.eval_frame.grid(row=1, sticky='EW')
        
        self.outlier_frame = OutlierFrame(self.fit_eval_frame, **frame_params)
        self.outlier_frame.grid(row=2, sticky='NSEW')
        
        self.fit_eval_frame.grid_columnconfigure(0, weight=1)
        self.fit_eval_frame.grid_rowconfigure(2, weight=1)


        self.note.add(self.data_time_frame,
                      text="Data")
        self.note.add(self.kernel_frame,
                      text="Kernel")
        self.note.add(self.fit_eval_frame,
                      text="Fit")
        
        self.note.grid(row=0, sticky='EWNS')

        self.status_frame = StatusBox(self, **frame_params)
        self.status_frame.grid(row=1, sticky='EWNS')

        self.control_frame = ControlBox(self)
        self.control_frame.grid(row=2, sticky='EW')
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)

class FitWindow(tk.Tk):
    def __init__(self, *args, **kwargs):
        # Need to use old, hackish way since tkinter uses old-style classes:
        tk.Tk.__init__(self, *args, **kwargs)
        
        self.wm_title("fit_profile %s" % (__version__,))

        self.control_frame = ControlFrame(self)
        self.control_frame.grid(row=0, column=1, sticky='NESW')

        self.plot_frame = PlotFrame(self)
        self.plot_frame.grid(row=0, column=0, sticky='NESW')

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)
        
        self.master_p = None
        self.p = None
        self.combined_p = None
        
        self.l = []
        self.e = []
        
        self.X = None
        self.res = None
    
    def load_data(self):
        self.master_p = collections.OrderedDict()
        self.efit_tree = None
        
        if (self.control_frame.data_source_frame.tree_file_frame.source_state.get() ==
                self.control_frame.data_source_frame.tree_file_frame.TREE_MODE):
            try:
                shot = int(self.control_frame.data_source_frame.shot_frame.shot_box.get())
                self.control_frame.status_frame.add_line("Loading data from shot number %d..." % (shot,))
                self.efit_tree = eqtools.CModEFITTree(shot)
            except ValueError:
                self.control_frame.status_frame.add_line("Invalid shot number! Loading of data from tree failed.")
                return
            include = [b.system for b in self.control_frame.data_source_frame.system_frame.buttons if b.state_var.get()]
            signal = self.control_frame.data_source_frame.signal_coordinate_frame.signal_var.get()
            for system in include:
                self.control_frame.status_frame.add_line("Loading data from %s..." % (system,))
                try:
                    if signal == 'ne':
                        self.master_p[system] = profiletools.ne(
                            shot,
                            include=[system],
                            efit_tree=self.efit_tree
                        )
                    elif signal == 'Te':
                        self.master_p[system] = profiletools.Te(
                            shot,
                            include=[system],
                            remove_ECE_edge=False,
                            efit_tree=self.efit_tree
                        )
                    else:
                        self.control_frame.status_frame.add_line("Unsupported signal %s." % (signal,))
                except MDSplus.TreeException as e:
                    self.control_frame.status_frame.add_line(
                        "Could not fetch data from the tree for system %s. "
                        "Exception was: %s" % (system, e,)
                    )
            if not self.master_p:
                self.control_frame.status_frame.add_line("No systems loaded! Loading of data from tree failed.")
                return
        else:
            path = self.control_frame.data_source_frame.tree_file_frame.path_entry.get()
            root, ext = os.path.splitext(path)
            path = os.path.abspath(os.path.expanduser(path))
            base = os.path.basename(path)
            if not os.path.isfile(path):
                self.control_frame.status_frame.add_line(
                    "File %s does not exist or is not a file! Loading of data "
                    "from file failed." % (path,)
                )
                return
            time_name = self.control_frame.data_source_frame.variable_name_frame.time_box.get()
            space_name = self.control_frame.data_source_frame.variable_name_frame.space_box.get()
            data_name = self.control_frame.data_source_frame.variable_name_frame.data_box.get()
            if space_name:
                if time_name:
                    X_names = [time_name, space_name]
                else:
                    X_names = [space_name]
            else:
                X_names = None
            if not data_name:
                data_name = None
            if ext.lower() == '.csv':
                metadata_lines = self.control_frame.data_source_frame.variable_name_frame.meta_box.get()
                try:
                    metadata_lines = int(metadata_lines)
                except ValueError:
                    if metadata_lines == '':
                        metadata_lines = None
                    else:
                        self.control_frame.status_frame.add_line(
                            "Invalid number of metadata lines! Loading of data from "
                            "file failed."
                        )
                        return
                self.control_frame.status_frame.add_line("Loading data from CSV file %s..." % (path,))
                self.master_p[base] = profiletools.read_plasma_csv(path,
                                                                     X_names=X_names,
                                                                     y_name=data_name,
                                                                     metadata_lines=metadata_lines)
            else:
                if X_names is None or data_name is None:
                    self.control_frame.status_frame.add_line(
                        "Must specify variable names when reading from a NetCDF "
                        "file! Loading of data from file failed."
                    )
                    return
                self.control_frame.status_frame.add_line("Loading data from NetCDF file %s..." % (path,))
                self.master_p[base] = profiletools.read_plasma_NetCDF(path,
                                                                      X_names,
                                                                      data_name)
            if hasattr(self.master_p[base], 'shot'):
                self.control_frame.data_source_frame.shot_frame.shot_box.delete(0, tk.END)
                self.control_frame.data_source_frame.shot_frame.shot_box.insert(0, str(self.master_p[base].shot))
                self.efit_tree = self.master_p[base].efit_tree
            if hasattr(self.master_p[base], 't_min'):
                self.control_frame.averaging_frame.time_window_frame.window_button.invoke()
                self.control_frame.averaging_frame.time_window_frame.t_min_box.delete(0, tk.END)
                self.control_frame.averaging_frame.time_window_frame.t_min_box.insert(0, str(self.master_p[base].t_min))
            if hasattr(self.master_p[base], 't_max'):
                self.control_frame.averaging_frame.time_window_frame.window_button.invoke()
                self.control_frame.averaging_frame.time_window_frame.t_max_box.delete(0, tk.END)
                self.control_frame.averaging_frame.time_window_frame.t_max_box.insert(0, str(self.master_p[base].t_max))
            if hasattr(self.master_p[base], 'times'):
                self.control_frame.averaging_frame.time_window_frame.point_button.invoke()
                self.control_frame.averaging_frame.time_window_frame.times_box.delete(0, tk.END)
                self.control_frame.averaging_frame.time_window_frame.times_box.insert(0, str(self.master_p[base].times)[1:-1])
            # Set the coordinate selector
            self.control_frame.data_source_frame.signal_coordinate_frame.coordinate_var.set(self.master_p[base].abscissa)
            
        self.control_frame.status_frame.add_line("Loading of data complete.")
    
    def average_data(self):
        markercycle = itertools.cycle('o^sDH*')
        
        self.control_frame.status_frame.add_line("Averaging and plotting data...")
        if not self.master_p:
            self.load_data()
        
        self.plot_frame.a_val.clear()
        self.plot_frame.a_grad.clear()
        self.plot_frame.a_a_L.clear()
        
        method = self.control_frame.averaging_frame.method_frame.method_var.get()
        y_method = self.control_frame.averaging_frame.method_frame.error_method_var.get()
        abscissa = self.control_frame.data_source_frame.signal_coordinate_frame.coordinate_var.get()
        
        window_mode = (self.control_frame.averaging_frame.time_window_frame.method_state.get() ==
                       self.control_frame.averaging_frame.time_window_frame.WINDOW_MODE)
        
        core_only = self.control_frame.kernel_frame.kernel_type_frame.core_only_state.get()
        
        times = []
        
        if window_mode:
            try:
                t_min = float(self.control_frame.averaging_frame.time_window_frame.t_min_box.get())
            except ValueError:
                t_min = None
                self.control_frame.status_frame.add_line("Invalid value for t_min. No lower bound applied.")
            try:
                t_max = float(self.control_frame.averaging_frame.time_window_frame.t_max_box.get())
            except ValueError:
                t_max = None
                self.control_frame.status_frame.add_line("Invalid value for t_max. No upper bound applied.")
        else:
            s_times = re.findall(r'([0-9.]+)[^0-9.]*',
                                 self.control_frame.averaging_frame.time_window_frame.times_box.get())
            for t in s_times:
                try:
                    times.append(float(t))
                except ValueError:
                    self.control_frame.status_frame.add_line(
                        "Invalid value %s in time points, will be ignored." % (t,)
                    )
            if not times:
                self.control_frame.status_frame.add_line("No valid points in time points. No bounding applied.")
        
        self.p = copy.deepcopy(self.master_p)
        for k, p in self.p.iteritems():
            self.control_frame.status_frame.add_line("Processing data from %s..." % (k,))
            # Restore the master tree so they can all share data:
            p.efit_tree = self.efit_tree
            # Restrict data to desired time points:
            if p.X_dim > 1:
                if window_mode:
                    if t_min is not None:
                        p.remove_points(scipy.asarray(p.X[:, 0]).flatten() < t_min)
                    if t_max is not None:
                        p.remove_points(scipy.asarray(p.X[:, 0]).flatten() > t_max)
                else:
                    if times:
                        p.keep_times(times)
                # Convert abscissa if needed:
                # TODO: This will need to be moved outside of the X_dim>1 test once convert_abscissa supports already-averaged data!
                try:
                    p.convert_abscissa(abscissa)
                except Exception as e:
                    self.control_frame.status_frame.add_line(
                        "Conversion to coordinate %s from %s failed for system %s."
                        % (abscissa, p.abscissa, k)
                    )
                    print(e)
                if len(times) == 1 or method == "all points":
                    p.drop_axis(0)
                else:
                    p.time_average(robust=(method == "robust"), y_method=y_method)
            if 'GPC' in k or 'ECE' in k or core_only:
                p.remove_edge_points()
        
            p.plot_data(ax=self.plot_frame.a_val, fmt=markercycle.next())
        
        self.control_frame.status_frame.add_line("Combining profiles...")
        
        p_list = []
        for p in self.p.values():
            p_list.append(p)
        self.combined_p = copy.deepcopy(p_list.pop())
        for p_other in p_list:
            self.combined_p.add_profile(p_other)
        
        if self.control_frame.outlier_frame.extreme_state.get():
            self.control_frame.status_frame.add_line("Removing points that exhibit extreme changes...")
            try:
                X_bad_c, y_bad_c, err_X_bad_c, err_y_bad_c = \
                    self.combined_p.remove_extreme_changes(thresh=float(self.control_frame.outlier_frame.extreme_thresh_box.get()))
                X_bad_c = scipy.asarray(X_bad_c).flatten()
                err_X_bad_c = scipy.asarray(err_X_bad_c).flatten()
                self.control_frame.status_frame.add_line("Removed %d points with extreme changes." % (len(y_bad_c),))
                
                if len(y_bad_c) > 0:
                    self.plot_frame.a_val.plot(X_bad_c, y_bad_c, 'mx',
                                               label='extreme change', ms=14)
            except ValueError:
                self.control_frame.status_frame.add_line("Invalid threshold for extreme change rejection!")
        
        self.plot_frame.a_val.set_ylabel(
            "%s [%s]" % (self.combined_p.y_label, self.combined_p.y_units,) if self.combined_p.y_units
            else self.combined_p.y_label)
        self.plot_frame.a_val.set_xlim((self.combined_p.X.min(), self.combined_p.X.max()))
        self.plot_frame.a_val.set_ylim(bottom=0)
        self.plot_frame.a_val.legend(loc='best', fontsize=12, ncol=2)
        self.plot_frame.canvas.draw()
        self.plot_frame.canvas._tkcanvas.focus_set()
        self.control_frame.status_frame.add_line("Averaging and plotting of data complete.")
    
    def process_bounds(self):
        for k, l, u in zip(range(0, len(self.combined_p.gp.k.hyperprior.bounds)),
                           self.control_frame.kernel_frame.bounds_frame.lower_bounds,
                           self.control_frame.kernel_frame.bounds_frame.upper_bounds):
            old_bounds = self.combined_p.gp.k.hyperprior.bounds[k]
            new_bounds = list(old_bounds)
            
            new_lb = l.get()
            try:
                new_bounds[0] = float(new_lb)
            except ValueError:
                if new_lb == '':
                    l.insert(0, str(old_bounds[0]))
                else:
                    self.control_frame.status_frame.add_line(
                        "Invalid lower bound %s for %s, will use default value "
                        "instead." % (new_lb, k,)
                    )
                
            new_ub = u.get()
            try:
                new_bounds[1] = float(new_ub)
            except ValueError:
                if new_ub == '':
                    u.insert(0, str(old_bounds[1]))
                else:
                    self.control_frame.status_frame.add_line(
                        "Invalid upper bound %s for %s, will use default value "
                        "instead." % (new_ub, k,)
                    )
            
            self.combined_p.gp.k.hyperprior.bounds[k] = new_bounds
    
    def fit_data(self):
        if not self.combined_p:
            self.average_data()
        
        if (self.control_frame.eval_frame.method_state.get() ==
                self.control_frame.eval_frame.UNIFORM_GRID):
            try:
                X_min = float(self.control_frame.eval_frame.x_min_box.get())
            except ValueError:
                self.control_frame.status_frame.add_line(
                    "Invalid lower bound for uniform grid!"
                )
                return
            try:
                X_max = float(self.control_frame.eval_frame.x_max_box.get())
            except ValueError:
                self.control_frame.status_frame.add_line(
                    "Invalid upper bound for uniform grid!"
                )
                return
            try:
                npts = int(self.control_frame.eval_frame.npts_box.get())
            except ValueError:
                self.control_frame.status_frame.add_line(
                    "Invalid number of points for uniform grid!"
                )
                return
            X = scipy.linspace(X_min, X_max, npts)
        else:
            X = []
            s_points = re.findall(r'([0-9.]+)[^0-9.]*',
                                  self.control_frame.eval_frame.x_points_box.get())
            for p in s_points:
                try:
                    X.append(float(p))
                except ValueError:
                    self.control_frame.status_frame.add_line(
                        "Invalid value %s in evaluation points, will be ignored." % (p,)
                    )
            if not X:
                self.control_frame.status_frame.add_line("No valid points in evaluation points!")
                return
        
        self.control_frame.status_frame.add_line("Creating Gaussian process...")
        self.combined_p.create_gp(k=self.control_frame.kernel_frame.kernel_type_frame.k_var.get(),
                                  constrain_slope_on_axis=False,
                                  constrain_at_limiter=False,
                                  upper_factor=args.upper_factor,
                                  lower_factor=args.lower_factor)
        # Process core constraint:
        if self.control_frame.kernel_frame.constraints_frame.core_state.get():
            s_core_loc = self.control_frame.kernel_frame.constraints_frame.core_loc.get()
            if s_core_loc == '':
                self.combined_p.constrain_slope_on_axis()
            else:
                try:
                    core_loc = float(s_core_loc)
                    self.combined_p.gp.add_data(core_loc, 0, err_y=0, n=1)
                except ValueError:
                    self.control_frame.status_frame.add_line(
                        "Invalid core constraint location %s, constraint will not be applied!" % (s_core_loc,)
                    )
        # Process edge constraint:
        if self.control_frame.kernel_frame.constraints_frame.edge_state.get():
            s_edge_locs = self.control_frame.kernel_frame.constraints_frame.edge_loc.get()
            if s_edge_locs == '':
                self.combined_p.constrain_at_limiter()
            else:
                s_edge_locs = re.findall(r'([0-9.]+)[^0-9.]*', s_edge_locs)
                edge_locs = []
                for loc in s_edge_locs:
                    try:
                        edge_locs.append(float(loc))
                    except ValueError:
                        self.control_frame.status_frame.add_line(
                            "Invalid edge constraint location %s in edge locations, will be ignored." % (loc,)
                        )
                if len(edge_locs) == 0:
                    self.control_frame.status_frame.add_line(
                        "No valid edge constraint locations, constraint will not be applied!"
                    )
                else:
                    self.combined_p.gp.add_data(edge_locs, 0, err_y=0.01, n=0)
                    self.combined_p.gp.add_data(edge_locs, 0, err_y=0.1, n=1)
        # Process bounds:
        self.process_bounds()
        
        self.control_frame.status_frame.add_line("Gaussian process created.")
        
        # Process outliers:
        # TODO: Put points back in if fit fails!
        remove_outliers = self.control_frame.outlier_frame.outlier_state.get()
        if remove_outliers:
            self.control_frame.status_frame.add_line("Finding outliers...")
            self.control_frame.status_frame.add_line("Finding initial MAP estimate...")
            self.find_MAP()
            thresh = float(self.control_frame.outlier_frame.outlier_thresh_box.get())
            X_bad_o, y_bad_o, err_X_bad_o, err_y_bad_o = \
                self.combined_p.remove_outliers(thresh=thresh)
            X_bad_o = scipy.asarray(X_bad_o).flatten()
            err_X_bad_o = scipy.asarray(err_X_bad_o).flatten()
            
            # Perform a second MAP estimation to put back IN the outliers that
            # now don't look so outlying:
            self.control_frame.status_frame.add_line("Found %d candidate outliers." % (len(y_bad_o),))
            if len(y_bad_o) > 0:
                self.control_frame.status_frame.add_line("Finding second MAP estimate...")
                self.find_MAP()
                mean = self.combined_p.gp.predict(X_bad_o, n=0, noise=False, return_std=False)
                deltas = scipy.absolute(mean - y_bad_o) / err_y_bad_o
                deltas[err_y_bad_o == 0] = 0
                bad_idxs = (deltas >= thresh)
                good_idxs = ~bad_idxs
                self.combined_p.add_data(
                    X_bad_o[good_idxs],
                    y_bad_o[good_idxs],
                    err_X=err_X_bad_o[good_idxs],
                    err_y=err_y_bad_o[good_idxs]
                )
                self.combined_p.gp.add_data(
                    X_bad_o[good_idxs],
                    y_bad_o[good_idxs],
                    err_y=err_y_bad_o[good_idxs]
                )
            
                self.control_frame.status_frame.add_line("Removed %d outliers." % (len(y_bad_o[bad_idxs]),))
                if len(y_bad_o[bad_idxs]) > 0:
                    self.plot_frame.a_val.plot(X_bad_o[bad_idxs], y_bad_o[bad_idxs], 'rx',
                                               label='outlier', ms=14)
        
        # Do the voodoo:
        use_MCMC = (
            self.control_frame.fitting_frame.method_frame.method_state.get() ==
            self.control_frame.fitting_frame.method_frame.USE_MCMC
        )
        if not use_MCMC:
            self.control_frame.status_frame.add_line("Finding MAP estimate...")
            self.find_MAP()
        
        # Evaluate:
        self.control_frame.status_frame.add_line("Evaluating fit...")
        
        full_MC = self.control_frame.fitting_frame.MCMC_constraint_frame.full_MC_state.get()
        compute_a_L = self.control_frame.eval_frame.a_L_state.get()
        if full_MC:
            positivity_constraint = self.control_frame.fitting_frame.MCMC_constraint_frame.pos_state.get()
            monotonicity_constraint = compute_a_L and self.control_frame.fitting_frame.MCMC_constraint_frame.mono_state.get()
            
            rejection_func = profiletools.RejectionFunc(
                X <= self.combined_p.X.max(),
                positivity=positivity_constraint,
                monotonicity=monotonicity_constraint
            )
            try:
                if not use_MCMC:
                    num_samples = int(self.control_frame.fitting_frame.MCMC_constraint_frame.samples_box.get())
                else:
                    num_samples = 1
            except ValueError:
                self.control_frame.status_frame.add_line(
                    "Invalid number of Monte Carlo samples! Disabling use of full "
                    "Monte Carlo."
                )
                full_MC = False
                num_samples = 1
        else:
            num_samples = 1
            rejection_func = None
        
        self.sampler = None
        
        if use_MCMC:
            self.control_frame.status_frame.add_line(
                "Running MCMC sampler..."
            )
            self.run_MCMC_sampler()
            
            MCMC_results_window = MCMCWindow(self)
            # MCMC_results_window.transient(self)
            MCMC_results_window.grab_set()
            self.wait_window(MCMC_results_window)
            # MCMC_results_window.destroy()
            if self.sampler:
                try:
                    self.sampler.pool.close()
                except AttributeError:
                    pass
                try:
                    burn = int(self.control_frame.fitting_frame.MCMC_frame.burn_box.get())
                except ValueError:
                    self.control_frame.status_frame.add_line(
                        "Invalid value for burn! Evaluation failed."
                    )
                    return
                if burn >= self.sampler.chain.shape[1]:
                    burn = 0
                    self.control_frame.status_frame.add_line(
                        "Not enough points, setting burn to 0!"
                    )
                try:
                    thin = max(self.sampler.chain.shape[0] * (self.sampler.chain.shape[1] - burn) // int(self.control_frame.fitting_frame.MCMC_frame.keep_box.get()), 1)
                    print(thin)
                except ValueError:
                    self.control_frame.status_frame.add_line(
                        "Invalid value for keep! Evaluation failed."
                    )
                    return
                self.control_frame.status_frame.add_line(
                    "MCMC sampling complete.\nComputing profile from samples..."
                )
            else:
                self.control_frame.status_frame.add_line(
                    "MCMC evaluation aborted."
                )
                return
        else:
            burn = None
            thin = None
        try:
            # TODO: Implement evaluation of vol_avg and peaking here!
            compute_vol_avg = self.control_frame.eval_frame.vol_avg_state.get()
            compute_peaking = self.control_frame.eval_frame.peaking_state.get()
            if compute_vol_avg or compute_peaking:
                dum, weights = self.combined_p._make_volume_averaging_matrix(rho_grid=X)
                if compute_a_L:
                    weights = scipy.hstack((weights, scipy.zeros_like(weights)))
                    output_transform = scipy.vstack((weights, scipy.eye(2 * len(X))))
                else:
                    output_transform = scipy.vstack((weights, scipy.eye(len(X))))
                # This will put the volume average as the first element.
                if compute_peaking:
                    if 'psinorm' in self.combined_p.abscissa:
                        if self.combined_p.abscissa.startswith('sqrt'):
                            core_loc = scipy.sqrt(0.2)
                        else:
                            core_loc = 0.2
                    else:
                        times = self.combined_p._get_efit_times_to_average()
                
                        # TODO: Verify with Martin that rho really means psinorm in his 2007 paper!
                        core_loc = self.combined_p.efit_tree.rho2rho(
                            'psinorm',
                            self.combined_p.abscissa,
                            times,
                            each_t=True
                        )
                        core_loc = scipy.mean(core_loc)
                    X = scipy.insert(X, 0, core_loc)
                    output_transform = scipy.insert(output_transform, 0, 0, axis=1)
                    core_select = scipy.zeros(output_transform.shape[1])
                    core_select[0] = 1
                    output_transform = scipy.insert(output_transform, 1, core_select, axis=0)
                    # This will put w(psinorm=0.2) as the second element and the
                    # volume average as the first element.
            else:
                output_transform = None
            
            if compute_peaking:
                special_vals = 2
            elif compute_vol_avg:
                special_vals = 1
            else:
                special_vals = 0
            
            if compute_a_L:
                res = self.combined_p.compute_a_over_L(
                    X,
                    use_MCMC=use_MCMC,
                    sampler=self.sampler,
                    return_prediction=True,
                    full_MC=full_MC,
                    rejection_func=rejection_func,
                    num_samples=num_samples,
                    burn=burn,
                    thin=thin,
                    output_transform=output_transform,
                    special_vals=special_vals,
                    special_X_vals=int(compute_peaking)
                )
            else:
                res = self.combined_p.smooth(
                    X,
                    n=0,
                    use_MCMC=use_MCMC,
                    sampler=self.sampler,
                    full_output=True,
                    full_MC=full_MC,
                    rejection_func=rejection_func,
                    num_samples=num_samples,
                    burn=burn,
                    thin=thin,
                    output_transform=output_transform
                )
                res['special_mean'] = res['mean'][:special_vals]
                res['special_cov'] = res['cov'][:special_vals, :special_vals]
                res['mean_val'] = res.pop('mean')[special_vals:]
                res['std_val'] = res.pop('std')[special_vals:]
        except numpy.linalg.LinAlgError as e:
            self.control_frame.status_frame.add_line(
                "Evaluation failed! Try re-running and/or adjusting bounds/number "
                "of samples. Exception was: %s" % (e,)
            )
            if args.no_interaction:
                raise e
            return
        
        self.mean_peaking = None
        self.std_peaking = None
        self.mean_vol_avg = None
        self.std_vol_avg = None
        
        if compute_vol_avg or compute_peaking:
            self.mean_vol_avg = res['special_mean'][0]
            self.std_vol_avg = scipy.sqrt(res['special_cov'][0, 0])
            if compute_vol_avg:
                if self.combined_p.y_units:
                    self.control_frame.status_frame.add_line(
                        u"Volume average is (%f\u00b1%f) %s"
                        % (self.mean_vol_avg, self.std_vol_avg,
                           self.combined_p.y_units.translate(None, '\\${}'),)
                    )
                else:
                    self.control_frame.status_frame.add_line(
                        u"Volume average is %f\u00b1%f"
                        % (self.mean_vol_avg, self.std_vol_avg,)
                    )
            if compute_peaking:
                mean_w2 = res['special_mean'][1]
                std_w2 = scipy.sqrt(res['special_cov'][1, 1])
                cov_w2_vol_avg = res['special_cov'][0, 1]
                self.mean_peaking = mean_w2 / self.mean_vol_avg
                self.std_peaking = scipy.sqrt(
                    std_w2 / self.mean_vol_avg**2 +
                    self.std_vol_avg * mean_w2**2 / self.mean_vol_avg**4 -
                    cov_w2_vol_avg * mean_w2 / self.mean_vol_avg**3
                )
                self.control_frame.status_frame.add_line(
                    u"Peaking is %f\u00b1%f"
                    % (self.mean_peaking, self.std_peaking,)
                )
                # Delete the extra points so they don't confuse the plot/file output:
                X = X[1:]
        
        if full_MC:
            self.control_frame.status_frame.add_line(
                "Got %d samples that met the constraints." % (res['samp'].shape[1],)
            )
        
        self.res = res
        self.X = X
        
        for line in self.l:
            try:
                line.remove()
            except ValueError:
                pass
        for env in self.e:
            try:
                env.remove()
            except ValueError:
                pass
        
        self.l, self.e = gptools.univariate_envelope_plot(X, res['mean_val'], res['std_val'], ax=self.plot_frame.a_val, color='b')
        if self.control_frame.eval_frame.a_L_state.get():
            color = plt.getp(self.l[0], 'color')
            core_mask = X <= 1
            l, e = gptools.univariate_envelope_plot(
                X,
                res['mean_grad'],
                res['std_grad'],
                ax=self.plot_frame.a_grad,
                color=color
            )
            self.plot_frame.a_grad.set_ylim(
                bottom=(res['mean_grad'][core_mask] - 3 * res['std_grad'][core_mask]).min(),
                top=(res['mean_grad'][core_mask] + 3 * res['std_grad'][core_mask]).max()
            )
            self.l.extend(l)
            self.e.extend(e)
            l, e = gptools.univariate_envelope_plot(
                X,
                res['mean_a_L'],
                res['std_a_L'],
                ax=self.plot_frame.a_a_L,
                color=color
            )
            self.plot_frame.a_a_L.set_ylim(
                bottom=(res['mean_a_L'][core_mask] - 3 * res['std_a_L'][core_mask]).min(),
                top=(res['mean_a_L'][core_mask] + 3 * res['std_a_L'][core_mask]).max()
            )
            self.l.extend(l)
            self.e.extend(e)
        
        self.plot_frame.a_grad.set_xlabel(self.plot_frame.a_val.get_xlabel())
        self.plot_frame.a_a_L.set_xlabel(self.plot_frame.a_val.get_xlabel())
        
        y_units = self.combined_p.y_units
        if not y_units:
            y_units = '1'
        X_units = self.combined_p.X_units[0]
        if X_units:
            X_units = '/' + X_units
        combined_units = y_units + X_units
        if combined_units != '1':
            label = "$d%s/d%s$ [%s]" % (self.combined_p.y_label.strip('$'), self.combined_p.X_labels[0].strip('$'), combined_units)
        else:
            label = "$d%s/d%s$" % (self.combined_p.y_label.strip('$'), self.combined_p.X_labels[0])
        self.plot_frame.a_grad.set_ylabel(label)
        
        self.plot_frame.a_a_L.set_ylabel("$a/L_{%s}$" % (self.combined_p.y_label.strip('$'),))
        
        self.plot_frame.a_val.set_xlim((min(X), max(X)))
        self.plot_frame.a_val.set_ylim(bottom=0)
        self.plot_frame.a_val.legend(loc='best', fontsize=12, ncol=2)
        self.plot_frame.canvas.draw()
        self.plot_frame.canvas._tkcanvas.focus_set()
        self.control_frame.status_frame.add_line("Fitting complete.")
    
    def find_MAP(self):
        try:
            res_min, complete = self.combined_p.find_gp_MAP_estimate(
                random_starts=int(self.control_frame.fitting_frame.method_frame.starts_box.get()),
                verbose=True
            )
        except ValueError as e:
            self.control_frame.status_frame.add_line(
                "MAP estimate failed. Hyperparameters should not be trusted! Try "
                "re-running the fit with more random starts."
            )
            if args.no_interaction:
                raise e
        else:
            self.control_frame.status_frame.add_line(
                "MAP estimate complete. Result is:"
            )
            k_nk = self.combined_p.gp.k + self.combined_p.gp.noise_k
            for v, l in zip(k_nk.free_params, k_nk.free_param_names):
                self.control_frame.status_frame.add_line("%s\t%.3e" % (l.translate(None, '\\'), v))
            if complete < 4:
                self.control_frame.status_frame.add_line(
                    "Less than 4 completed starts were obtained. Try increasing "
                    "the number of random starts, or adjusting the hyperparameter "
                    "bounds."
                )
            if not res_min.success:
                self.control_frame.status_frame.add_line(
                    "Optimizer reports failure, selected hyperparameters "
                    "are likely NOT optimal. Status: %d, Message: '%s'. "
                    "Try adjusting bounds, initial guesses or the number "
                    "of random starts used."
                    % (res_min.status, res_min.message)
                )
            bounds = scipy.asarray(k_nk.free_param_bounds)
            if ((res_min.x <= 1.001 * bounds[:, 0]).any() or
                (res_min.x >= 0.999 * bounds[:, 1]).any()):
                self.control_frame.status_frame.add_line(
                    "Optimizer appears to have hit/exceeded the bounds. Try "
                    "adjusting bounds, initial guesses or the number of random "
                    "starts used."
                )
    
    def run_MCMC_sampler(self):
        try:
            walkers = int(self.control_frame.fitting_frame.MCMC_frame.walker_box.get())
        except ValueError:
            self.control_frame.status_frame.add_line(
                "Invalid number of MCMC walkers! Evaluation failed."
            )
            self.sampler = None
            return
        try:
            samples = int(self.control_frame.fitting_frame.MCMC_frame.sample_box.get())
        except ValueError:
            self.control_frame.status_frame.add_line(
                "Invalid number of MCMC samples! Evaluation failed."
            )
            self.sampler = None
            return
        self.sampler = self.combined_p.gp.sample_hyperparameter_posterior(
            nsamp=samples,
            nwalkers=walkers,
            sampler=self.sampler
        )
    
    def save_fit(self, save_plot=False):
        if self.res is None:
            self.fit_data()
        if not args.output_filename:
            path = tkFileDialog.asksaveasfilename()
        else:
            path = args.output_filename
        if path:
            root, ext = os.path.splitext(path)
            if save_plot:
                title = 'fit_profile ' + __version__
                try:
                    title += " shot %d" % (self.combined_p.shot)
                except AttributeError:
                    pass
                try:
                    title += " t_min %f" % (self.combined_p.t_min)
                except AttributeError:
                    pass
                try:
                    title += " t_max %f" % (self.combined_p.t_max)
                except AttributeError:
                    pass
                if hasattr(self.combined_p, 'times'):
                    times = list(self.combined_p.times)
                    title += " times %f" % (times.pop())
                    for t in times:
                        title += ",%f" % (t,)
                try:
                    title += " coordinate %s" % (self.combined_p.abscissa)
                except AttributeError:
                    pass
                
                self.plot_frame.f.suptitle(title)
                
                self.plot_frame.f.savefig(
                    os.path.expanduser(root) + '.pdf',
                    format='pdf'
                )
            history = (
                "Created by user {user} on {host} with {module} version {ver} on {time}.\n".format(
                    host=socket.gethostname(), user=getpass.getuser(),
                    module=inspect.stack()[0][1], ver=__version__, time=time.asctime()
                )
            )
            if ext.lower() == '.csv':
                self.control_frame.status_frame.add_line(
                    "Writing results to CSV file %s..." % os.path.basename(path)
                )
                X_name = self.combined_p.X_labels[0] + ' [' + self.combined_p.X_units[0] + ']' if self.combined_p.X_units[0] else self.combined_p.X_labels[0]
                y_name = self.combined_p.y_label + ' [' + self.combined_p.y_units + ']' if self.combined_p.y_units else self.combined_p.y_label
                with open(os.path.expanduser(path), 'wb') as outfile:
                    # Write metadata:
                    metadata = history
                    try:
                        metadata += "shot %d\n" % (self.combined_p.shot)
                    except AttributeError:
                        pass
                    try:
                        metadata += "t_min %f\n" % (self.combined_p.t_min)
                    except AttributeError:
                        pass
                    try:
                        metadata += "t_max %f\n" % (self.combined_p.t_max)
                    except AttributeError:
                        pass
                    if hasattr(self.combined_p, 'times'):
                        times = list(self.combined_p.times)
                        metadata += "times %f" % (times.pop())
                        for t in times:
                            metadata += ",%f" % (t,)
                        metadata += "\n"
                    try:
                        metadata += "coordinate %s\n" % (self.combined_p.abscissa)
                    except AttributeError:
                        pass
                    
                    if self.mean_vol_avg:
                        metadata += "vol_avg %f\nerr_vol_avg %f\n" % (self.mean_vol_avg, self.std_vol_avg,)
                    if self.mean_peaking:
                        metadata += "peaking %f\nerr_peaking %f\n" % (self.mean_peaking, self.std_peaking,)
                    
                    outfile.write(
                        "metadata %d\n" % (len(metadata.splitlines()) + 1,) + metadata
                    )
                    
                    writer = csv.writer(outfile)
                    if 'mean_a_L' in self.res:
                        writer.writerow(
                            [X_name,
                             y_name, 'err_' + y_name,
                             'D' + self.combined_p.y_label, 'err_D' + self.combined_p.y_label,
                             'a_L' + self.combined_p.y_label, 'err_a_L' + self.combined_p.y_label]
                        )
                        writer.writerows(zip(self.X,
                                             self.res['mean_val'], self.res['std_val'],
                                             self.res['mean_grad'], self.res['std_grad'],
                                             self.res['mean_a_L'], self.res['std_a_L']))
                    else:
                        writer.writerow([X_name, y_name, 'err_' + y_name])
                        writer.writerows(zip(self.X, self.res['mean_val'], self.res['std_val']))
            else:
                self.control_frame.status_frame.add_line(
                    "Writing results to NetCDF file %s..." % os.path.basename(path)
                )
                X_name = self.combined_p.X_labels[0].translate(None, '\\$')
                X_units = self.combined_p.X_units[0]
                y_name = self.combined_p.y_label.translate(None, '\\$')
                y_units = self.combined_p.y_units
            
                with scipy.io.netcdf.netcdf_file(os.path.expanduser(path), mode='w') as f:
                    f.history = history
                    try:
                        f.shot = self.combined_p.shot
                    except AttributeError:
                        pass
                    try:
                        f.t_min = self.combined_p.t_min
                    except AttributeError:
                        pass
                    try:
                        f.t_max  = self.combined_p.t_max
                    except AttributeError:
                        pass
                    try:
                        f.times = list(self.combined_p.times)
                    except AttributeError:
                        pass
                    try:
                        f.coordinate = self.combined_p.abscissa
                    except AttributeError:
                        pass
                    
                    if self.mean_vol_avg:
                        f.vol_avg = self.mean_vol_avg
                        f.err_vol_avg = self.std_vol_avg
                    if self.mean_peaking:
                        f.peaking = self.mean_peaking
                        f.err_peaking = self.std_peaking
                    
                    f.createDimension(X_name, len(self.X))
                    v_X = f.createVariable(X_name, float, (X_name,))
                    v_X[:] = self.X
                    v_X.units = X_units
                    v_y = f.createVariable(y_name, float, (X_name,))
                    v_y[:] = self.res['mean_val']
                    v_y.units = y_units
                    v_err_y = f.createVariable('err_'+y_name, float, (X_name,))
                    v_err_y[:] = self.res['std_val']
                    v_err_y.units = y_units
                    if 'mean_a_L' in self.res:
                        v_grad = f.createVariable("d%s/d%s" % (y_name, X_name), float, (X_name,))
                        v_grad[:] = self.res['mean_grad']
                        v_grad.units = y_units + '/' + X_units
                        v_err_grad = f.createVariable("err_d%s/d%s" % (y_name, X_name), float, (X_name,))
                        v_err_grad[:] = self.res['std_grad']
                        v_err_grad.units = y_units + '/' + X_units
                        
                        v_a_L = f.createVariable("a_L%s" % (y_name,), float, (X_name,))
                        v_a_L[:] = self.res['mean_a_L']
                        v_a_L.units = ''
                        v_err_a_L = f.createVariable("err_a_L%s" % (y_name,), float, (X_name,))
                        v_err_a_L[:] = self.res['std_a_L']
                        v_err_a_L.units = ''
            
            self.control_frame.status_frame.add_line(
                "Done writing results."
            )
    
    def exit(self):
        self.destroy()

class MCMCResultsFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        tk.Frame.__init__(self, *args, **kwargs)
        
        sampler = self.master.master.sampler
        k = sampler.flatchain.shape[1]
        
        self.f = Figure()
        gs1 = mplgs.GridSpec(k, k)
        gs2 = mplgs.GridSpec(1, k)
        gs1.update(bottom=0.275, top=0.98)
        gs2.update(bottom=0.1, top=0.2)
        self.axes = []
        # j is the row, i is the column.
        for j in xrange(0, k + 1):
            row = []
            for i in xrange(0, k):
                if i > j:
                    row.append(None)
                else:
                    sharey = row[-1] if i > 0 and i < j and j < k else None
                    sharex = self.axes[-1][i] if j > i and j < k else \
                        (row[-1] if i > 0 and j == k else None)
                    gs = gs1[j, i] if j < k else gs2[:, i]
                    row.append(self.f.add_subplot(gs, sharey=sharey, sharex=sharex))
            self.axes.append(row)
        self.axes = scipy.asarray(self.axes)
        
        self.canvas = FigureCanvasTkAgg(self.f, master=self)
        self.canvas.show()
        self.canvas.get_tk_widget().grid(row=0, column=0, sticky='NESW')

        self.toolbar_frame = tk.Frame(self)
        self.toolbar = NavigationToolbar2TkAgg(self.canvas, self.toolbar_frame)
        self.toolbar.update()
        # self.canvas._tkcanvas.grid(row=1, column=0, sticky='EW')
        self.toolbar_frame.grid(row=1, column=0, sticky='EW')

        self.canvas.mpl_connect('button_press_event', lambda event: self.canvas._tkcanvas.focus_set())
        self.canvas.mpl_connect('key_press_event', self.on_key_event)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)
        
        self.refresh()

    def on_key_event(self, evt):
        key_press_handler(evt, self.canvas, self.toolbar)
    
    def print_stats(self, box):
        sampler = self.master.master.sampler
        try:
            box.add_line("MCMC sampler autocorrelation times:\n%s" % (sampler.acor,))
        except RuntimeError:
            box.add_line("Could not compute MCMC sampler autocorrelation times.")
        box.add_line("MCMC sampler mean acceptance fraction: %.2f%%" % (100*scipy.mean(sampler.acceptance_fraction),))
    
    def refresh(self, print_stats=True):
        sampler = self.master.master.sampler
        
        if sampler:
            if print_stats:
                self.print_stats(self.master.MCMC_control_frame.help_box)
            labels = ['$%s$' % (l,) for l in self.master.master.combined_p.gp.k.free_param_names]
            k = sampler.flatchain.shape[1]
        
            try:
                burn = int(self.master.master.control_frame.fitting_frame.MCMC_frame.burn_box.get())
            except ValueError:
                self.master.MCMC_control_frame.help_box.add_line("Invalid value for burn! Defaulting to 0.")
                burn = 0
            if burn >= sampler.chain.shape[1]:
                burn = 0
        
            flat_trace = sampler.chain[:, burn:, :]
            flat_trace = flat_trace.reshape((-1, k))
        
            # j is the row, i is the column.
            # Loosely based on triangle.py
            for i in xrange(0, k):
                self.axes[i, i].clear()
                self.axes[i, i].hist(flat_trace[:, i], bins=50)
                if i == k - 1:
                    self.axes[i, i].set_xlabel(labels[i])
                if i < k - 1:
                    plt.setp(self.axes[i, i].get_xticklabels(), visible=False)
                plt.setp(self.axes[i, i].get_yticklabels(), visible=False)
                # for j in xrange(0, i):
                #     self.axes[j, i].set_visible(False)
                #     self.axes[j, i].set_frame_on(False)
                for j in xrange(i + 1, k):
                    self.axes[j, i].clear()
                    ct, x, y, im = self.axes[j, i].hist2d(flat_trace[:, i], flat_trace[:, j], bins=50)
                    # xmid = 0.5 * (x[1:] + x[:-1])
                    # ymid = 0.5 * (y[1:] + y[:-1])
                    # self.axes[j, i].contour(xmid, ymid, ct.T, colors='k')
                    if j < k - 1:
                        plt.setp(self.axes[j, i].get_xticklabels(), visible=False)
                    if i != 0:
                        plt.setp(self.axes[j, i].get_yticklabels(), visible=False)
                    if i == 0:
                        self.axes[j, i].set_ylabel(labels[j])
                    if j == k - 1:
                        self.axes[j, i].set_xlabel(labels[i])
                self.axes[-1, i].clear()
                self.axes[-1, i].plot(sampler.chain[:, :, i].T)
                self.axes[-1, i].axvline(burn, color='r', linewidth=3)
                self.axes[-1, i].set_ylabel(labels[i])
                self.axes[-1, i].set_xlabel('step')
        
            self.canvas.draw()
        else:
            self.master.MCMC_control_frame.help_box.add_line("Sampler is invalid, please set valid parameter values and resample!")

class MCMCControlFrame(tk.Frame):
    def __init__(self, *args, **kwargs):
        tk.Frame.__init__(self, *args, **kwargs)
        
        self.help_box = StatusBox(self, **frame_params)
        self.help_box.grid(row=0, column=0, sticky='EWNS')
        self.help_box.add_line(
"""\nCheck to make sure the output of the MCMC sampler
looks correct.

1.) The chains (bottom plots) should be well mixed:
    they should all overlap and not spend too much
    time in any given spot. Set burn to the
    iteration number at which they appear to
    become mixed and the initial transients have
    died down.

2.) The univariate marginals (diagonal of the
    matrix) should be peaked and go to zero near
    the edges. It is also preferable that they be
    unimodal. If they look wrong, try adjusting
    the bounds to exclude any unphysical modes.

3.) The bivariate marginals should also be unimodal.
"""
        )
        
        self.control_frame = tk.Frame(self)
        
        self.resample_button = tk.Button(self.control_frame, text="resample", command=self.resample)
        self.resample_button.grid(row=0, column=0, sticky='W')
        
        self.add_sample_button = tk.Button(self.control_frame, text="add samples", command=self.add_samples)
        self.add_sample_button.grid(row=0, column=1)
        
        self.burn_button = tk.Button(self.control_frame, text="apply burn", command=self.apply_burn)
        self.burn_button.grid(row=0, column=2)
        
        self.reject_button = tk.Button(self.control_frame, text="abort", command=self.abort)
        self.reject_button.grid(row=0, column=3, sticky='W')
        
        self.accept_button = tk.Button(self.control_frame, text="continue", command=self.continue_)
        self.accept_button.grid(row=0, column=4, sticky='W')
        
        self.control_frame.grid(row=3, column=0, sticky='EW')
        
        # TODO: Put in ability to change burn on-the-fly!
        
        self.entry_frame = MCMCFrame(self, **frame_params)
        self.entry_frame.grid(row=1, column=0, columnspan=5, sticky='EW')
        
        # Update from master frame:
        self.entry_frame.walker_box.delete(0, tk.END)
        self.entry_frame.walker_box.insert(0, self.master.master.control_frame.fitting_frame.MCMC_frame.walker_box.get())
        self.entry_frame.sample_box.delete(0, tk.END)
        self.entry_frame.sample_box.insert(0, self.master.master.control_frame.fitting_frame.MCMC_frame.sample_box.get())
        self.entry_frame.burn_box.delete(0, tk.END)
        self.entry_frame.burn_box.insert(0, self.master.master.control_frame.fitting_frame.MCMC_frame.burn_box.get())
        self.entry_frame.keep_box.delete(0, tk.END)
        self.entry_frame.keep_box.insert(0, self.master.master.control_frame.fitting_frame.MCMC_frame.keep_box.get())
        
        # Input hyperparameter bounds:
        self.bounds_meta_frame = tk.Frame(self, **frame_params)
        self.bounds_label = tk.Label(self.bounds_meta_frame, text="hyperparameter bounds:")
        self.bounds_label.grid(row=0, column=0, sticky='W')
        
        self.bounds_frame = KernelBoundsFrame(HYPERPARAMETERS[self.master.master.control_frame.kernel_frame.kernel_type_frame.k_var.get()], self.bounds_meta_frame)
        self.bounds_frame.grid(row=1, column=0, sticky='EW')
        
        self.bounds_meta_frame.grid(row=2, column=0, sticky='EW')
        
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)
        
        self.process_bounds()
    
    def process_bounds(self):
        for k, l, u in zip(range(0, len(self.master.master.combined_p.gp.k.hyperprior.bounds)),
                           self.bounds_frame.lower_bounds,
                           self.bounds_frame.upper_bounds):
            # We know that by the point this gets called, the hyperprior has the right bounds as set in the main window:
            old_bounds = self.master.master.combined_p.gp.k.hyperprior.bounds[k]
            new_bounds = list(old_bounds)
            
            new_lb = l.get()
            try:
                new_bounds[0] = float(new_lb)
            except ValueError:
                if new_lb == '':
                    l.insert(0, str(old_bounds[0]))
                else:
                    self.help_box.add_line(
                        "Invalid lower bound %s for %s, will use default value "
                        "instead." % (new_lb, k,)
                    )
                
            new_ub = u.get()
            try:
                new_bounds[1] = float(new_ub)
            except ValueError:
                if new_ub == '':
                    u.insert(0, str(old_bounds[1]))
                else:
                    self.help_box.add_line(
                        "Invalid upper bound %s for %s, will use default value "
                        "instead." % (new_ub, k,)
                    )
            
            self.master.master.combined_p.gp.k.hyperprior.bounds[k] = new_bounds
        
        # Propagate the bounds back to the main window:
        for l, u in zip(self.master.master.control_frame.kernel_frame.bounds_frame.lower_bounds,
                        self.master.master.control_frame.kernel_frame.bounds_frame.upper_bounds):
            l.delete(0, tk.END)
            u.delete(0, tk.END)
        self.master.master.process_bounds()
    
    def update_MCMC_params(self, walkers=True, sample=True, burn=True, thin=True):
        if walkers:
            self.master.master.control_frame.fitting_frame.MCMC_frame.walker_box.delete(0, tk.END)
            self.master.master.control_frame.fitting_frame.MCMC_frame.walker_box.insert(0, self.entry_frame.walker_box.get())
        if sample:
            self.master.master.control_frame.fitting_frame.MCMC_frame.sample_box.delete(0, tk.END)
            self.master.master.control_frame.fitting_frame.MCMC_frame.sample_box.insert(0, self.entry_frame.sample_box.get())
        if burn:
            self.master.master.control_frame.fitting_frame.MCMC_frame.burn_box.delete(0, tk.END)
            self.master.master.control_frame.fitting_frame.MCMC_frame.burn_box.insert(0, self.entry_frame.burn_box.get())
        if thin:
            self.master.master.control_frame.fitting_frame.MCMC_frame.keep_box.delete(0, tk.END)
            self.master.master.control_frame.fitting_frame.MCMC_frame.keep_box.insert(0, self.entry_frame.keep_box.get())
    
    def continue_(self):
        self.help_box.add_line("Continuing...")
        self.process_bounds()
        self.update_MCMC_params()
        self.master.destroy()
    
    def abort(self):
        self.help_box.add_line("Aborting evaluation...")
        self.process_bounds()
        self.master.master.sampler.pool.close()
        self.master.master.sampler = None
        self.master.destroy()
    
    def resample(self):
        self.help_box.add_line("Re-running MCMC sampler...")
        self.process_bounds()
        self.update_MCMC_params()
        try:
            self.master.master.sampler.pool.close()
        except AttributeError:
            pass
        self.master.master.sampler = None
        self.master.master.run_MCMC_sampler()
        self.master.MCMC_frame.refresh()
        self.help_box.add_line("Done resampling.")
    
    def add_samples(self):
        self.help_box.add_line("Adding new samples...")
        self.update_MCMC_params(walkers=False)
        self.master.master.run_MCMC_sampler()
        self.master.MCMC_frame.refresh()
        self.help_box.add_line("Done sampling.")
    
    def apply_burn(self):
        self.update_MCMC_params(walkers=False, sample=False, thin=False)
        self.master.MCMC_frame.refresh(print_stats=False)

class MCMCWindow(tk.Toplevel):
    def __init__(self, *args, **kwargs):
        tk.Toplevel.__init__(self, *args, **kwargs)
        
        self.wm_title("fit_profile %s: MCMC results" % (__version__,))
        
        self.MCMC_control_frame = MCMCControlFrame(self)
        
        self.MCMC_frame = MCMCResultsFrame(self)
        
        self.MCMC_frame.grid(row=0, column=0, sticky='NSEW')
        self.MCMC_control_frame.grid(row=0, column=1, sticky='NSEW')
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)

if __name__ == "__main__":
    root = FitWindow()
    
    # Populate the GUI with parameters from args:
    # TODO: Put some clever defaults here!
    # Turn off edge constraint for --core-only:
    if args.core_only:
        args.no_edge_constraint = True
        args.kernel = 'SE'

    # Bump random starts up to 4 for low processor count machines:
    if not args.random_starts:
        num_proc = multiprocessing.cpu_count()
        if num_proc < 4:
            # root.status_frame.add_line(
            #     "Number of processors available is less than 4. Setting random_starts "
            #     "to 4 to help ensure convergence of MAP estimation. You can override "
            #     "this by setting the number of random starts explicitly. Running on "
            #     "a computer with more cores will make this run much faster."
            # )
            args.random_starts = 4
        else:
            args.random_starts = num_proc
    
    if args.signal:
        root.control_frame.data_source_frame.signal_coordinate_frame.signal_var.set(args.signal)
        root.control_frame.data_source_frame.update_signal(args.signal)
    if args.shot is not None:
        root.control_frame.data_source_frame.shot_frame.shot_box.delete(0, tk.END)
        root.control_frame.data_source_frame.shot_frame.shot_box.insert(0, str(args.shot))
    if args.t_min is not None:
        root.control_frame.averaging_frame.time_window_frame.t_min_box.delete(0, tk.END)
        root.control_frame.averaging_frame.time_window_frame.t_min_box.insert(0, str(args.t_min))
    if args.t_max is not None:
        root.control_frame.averaging_frame.time_window_frame.t_max_box.delete(0, tk.END)
        root.control_frame.averaging_frame.time_window_frame.t_max_box.insert(0, str(args.t_max))
    if args.t_points:
        root.control_frame.averaging_frame.time_window_frame.point_button.invoke()
        root.control_frame.averaging_frame.time_window_frame.times_box.delete(0, tk.END)
        root.control_frame.averaging_frame.time_window_frame.times_box.insert(0, str(args.t_points)[1:-1])
    if args.npts is not None:
        root.control_frame.eval_frame.npts_box.delete(0, tk.END)
        root.control_frame.eval_frame.npts_box.insert(0, str(args.npts))
    if args.x_min is not None:
        root.control_frame.eval_frame.x_min_box.delete(0, tk.END)
        root.control_frame.eval_frame.x_min_box.insert(0, str(args.x_min))
    if args.x_max is not None:
        root.control_frame.eval_frame.x_max_box.delete(0, tk.END)
        root.control_frame.eval_frame.x_max_box.insert(0, str(args.x_max))
    if args.x_pts:
        root.control_frame.eval_frame.points_button.invoke()
        root.control_frame.eval_frame.x_points_box.delete(0, tk.END)
        root.control_frame.eval_frame.x_points_box.insert(0, str(args.x_pts)[1:-1])
    if args.system:
        systems = set(args.system)
        if 'TS' in systems:
            systems.remove('TS')
            systems.add('ETS')
            systems.add('CTS')
        for b in root.control_frame.data_source_frame.system_frame.buttons:
            if b.system in systems:
                b.button.select()
            else:
                b.button.deselect()
    if args.kernel:
        root.control_frame.kernel_frame.kernel_type_frame.k_var.set(args.kernel)
        root.control_frame.kernel_frame.update_kernel(args.kernel)
    if args.coordinate:
        root.control_frame.data_source_frame.signal_coordinate_frame.coordinate_var.set(args.coordinate)
    if args.core_constraint_location is not None:
        root.control_frame.kernel_frame.constraints_frame.core_loc.delete(0, tk.END)
        root.control_frame.kernel_frame.constraints_frame.core_loc.insert(0, str(args.core_constraint_location))
    if args.edge_constraint_locations:
        root.control_frame.kernel_frame.constraints_frame.edge_loc.delete(0, tk.END)
        root.control_frame.kernel_frame.constraints_frame.edge_loc.insert(0, str(args.edge_constraint_locations)[1:-1])
    if args.no_core_constraint:
        root.control_frame.kernel_frame.constraints_frame.core_button.deselect()
        root.control_frame.kernel_frame.constraints_frame.update_core()
    if args.no_edge_constraint:
        root.control_frame.kernel_frame.constraints_frame.edge_button.deselect()
        root.control_frame.kernel_frame.constraints_frame.update_edge()
    if args.core_only:
        root.control_frame.kernel_frame.kernel_type_frame.core_only_button.select()
    if args.robust:
        root.control_frame.averaging_frame.method_frame.method_var.set('robust')
    if args.all_points:
        root.control_frame.averaging_frame.method_frame.method_var.set('all points')
    root.control_frame.averaging_frame.method_frame.error_method_var.set(args.uncertainty_method)
    root.control_frame.averaging_frame.method_frame.update_method(
        root.control_frame.averaging_frame.method_frame.method_var.get()
    )
    if args.change_threshold is not None:
        root.control_frame.outlier_frame.extreme_button.invoke()
        root.control_frame.outlier_frame.extreme_thresh_box.delete(0, tk.END)
        root.control_frame.outlier_frame.extreme_thresh_box.insert(0, str(args.change_threshold))
    if args.outlier_threshold is not None:
        root.control_frame.outlier_frame.outlier_button.invoke()
        root.control_frame.outlier_frame.outlier_thresh_box.delete(0, tk.END)
        root.control_frame.outlier_frame.outlier_thresh_box.insert(0, str(args.outlier_threshold))
    if args.random_starts is not None:
        root.control_frame.fitting_frame.method_frame.starts_box.delete(0, tk.END)
        root.control_frame.fitting_frame.method_frame.starts_box.insert(0, str(args.random_starts))
    if args.bounds:
        for k in xrange(0, len(root.control_frame.kernel_frame.bounds_frame.lower_bounds)):
            root.control_frame.kernel_frame.bounds_frame.lower_bounds[k].delete(0, tk.END)
            root.control_frame.kernel_frame.bounds_frame.lower_bounds[k].insert(0, str(args.bounds[2*k]))
            root.control_frame.kernel_frame.bounds_frame.upper_bounds[k].delete(0, tk.END)
            root.control_frame.kernel_frame.bounds_frame.upper_bounds[k].insert(0, str(args.bounds[2*k+1]))
    if args.input_filename:
        root.control_frame.data_source_frame.tree_file_frame.file_button.invoke()
        root.control_frame.data_source_frame.tree_file_frame.path_entry.delete(0, tk.END)
        root.control_frame.data_source_frame.tree_file_frame.path_entry.insert(0, args.input_filename)
    if args.abscissa_name:
        root.control_frame.data_source_frame.tree_file_frame.file_button.invoke()
        if len(args.abscissa_name) == 2:
            root.control_frame.data_source_frame.variable_name_frame.time_box.delete(0, tk.END)
            root.control_frame.data_source_frame.variable_name_frame.time_box.insert(0, str(args.abscissa_name[0]))
        root.control_frame.data_source_frame.variable_name_frame.space_box.delete(0, tk.END)
        root.control_frame.data_source_frame.variable_name_frame.space_box.insert(0, str(args.abscissa_name[-1]))
    if args.ordinate_name:
        root.control_frame.data_source_frame.tree_file_frame.file_button.invoke()
        root.control_frame.data_source_frame.variable_name_frame.data_box.delete(0, tk.END)
        root.control_frame.data_source_frame.variable_name_frame.data_box.insert(0, str(args.ordinate_name))
    if args.metadata_lines is not None:
        root.control_frame.data_source_frame.variable_name_frame.meta_box.delete(0, tk.END)
        root.control_frame.data_source_frame.variable_name_frame.meta_box.insert(0, str(args.metadata_lines))
    if args.use_MCMC:
        root.control_frame.fitting_frame.method_frame.MCMC_button.invoke()
    if args.walkers is not None:
        root.control_frame.fitting_frame.MCMC_frame.walker_box.delete(0, tk.END)
        root.control_frame.fitting_frame.MCMC_frame.walker_box.insert(0, str(args.walkers))
    if args.MCMC_samp is not None:
        root.control_frame.fitting_frame.MCMC_frame.sample_box.delete(0, tk.END)
        root.control_frame.fitting_frame.MCMC_frame.sample_box.insert(0, str(args.MCMC_samp))
    if args.burn is not None:
        root.control_frame.fitting_frame.MCMC_frame.burn_box.delete(0, tk.END)
        root.control_frame.fitting_frame.MCMC_frame.burn_box.insert(0, str(args.burn))
    if args.keep is not None:
        root.control_frame.fitting_frame.MCMC_frame.keep_box.delete(0, tk.END)
        root.control_frame.fitting_frame.MCMC_frame.keep_box.insert(0, str(args.keep))
    if args.full_monte_carlo:
        root.control_frame.fitting_frame.MCMC_constraint_frame.full_MC_button.select()
        root.control_frame.fitting_frame.MCMC_constraint_frame.update_full_MC()
    if args.monte_carlo_samples:
        state = root.control_frame.fitting_frame.MCMC_constraint_frame.samples_box['state']
        root.control_frame.fitting_frame.MCMC_constraint_frame.samples_box.config(state=tk.NORMAL)
        root.control_frame.fitting_frame.MCMC_constraint_frame.samples_box.delete(0, tk.END)
        root.control_frame.fitting_frame.MCMC_constraint_frame.samples_box.insert(0, str(args.monte_carlo_samples))
        root.control_frame.fitting_frame.MCMC_constraint_frame.samples_box.config(state=state)
    if args.reject_negative:
        root.control_frame.fitting_frame.MCMC_constraint_frame.pos_button.select()
    if args.reject_non_monotonic:
        root.control_frame.fitting_frame.MCMC_constraint_frame.mono_button.select()
    if args.no_a_over_L:
        root.control_frame.eval_frame.a_L_button.deselect()
    root.control_frame.eval_frame.update_a_L()
    if args.compute_vol_avg:
        root.control_frame.eval_frame.vol_avg_button.select()
    if args.compute_peaking:
        root.control_frame.eval_frame.peaking_button.select()
    
    if args.full_auto or args.no_interaction:
        root.load_data()
        root.average_data()
        root.fit_data()
        if args.no_interaction:
            root.save_fit(save_plot=True)
            root.exit()
        
    if not args.no_interaction:
        root.mainloop()
