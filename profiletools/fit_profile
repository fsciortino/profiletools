#!/usr/bin/env python2.7
# Copyright 2014 Mark Chilenski
# This program is distributed under the terms of the GNU General Purpose License (GPL).
# Refer to http://www.gnu.org/licenses/gpl.txt
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import division
import argparse
import sys
import scipy.io
import profiletools

parser = argparse.ArgumentParser(
    description="Fit univariate profile using gptools/profiletools. Must either "
                "specify signal with -s or input NetCDF file with -i.",
    formatter_class=argparse.ArgumentDefaultsHelpFormatter
)
parser.add_argument('--signal',
                    choices=['ne', 'Te'],
                    help="Which signal to fit. This argument is required.")
parser.add_argument('--shot',
                    type=int,
                    help="Shot number to use.")
parser.add_argument('--t-min',
                    type=float,
                    help="Starting time of period to average over.")
parser.add_argument('--t-max',
                    type=float,
                    help="Ending time of period to average over.")
parser.add_argument('-t', '--t-point',
                    type=float,
                    help="Single time value to average over. The nearest time "
                         "to this will be selected. You must either specify "
                         "--t-min and --t-max, or -t.")
parser.add_argument('--system',
                    nargs='+',
                    choices=['CTS', 'ETS', 'TS', 'GPC', 'GPC2', 'FRCECE'],
                    help="Which system(s) to take data from. If not provided, "
                         "all applicable systems will be used. The 'TS' option "
                         "is a shortcut to include both the core (CTS) and edge "
                         "(ETS) Thomson systems.")
parser.add_argument('--kernel',
                    choices=['gibbstanh', 'SE'],
                    default='gibbstanh',
                    help="Which covariance kernel to used. This dictates the "
                         "properties of the fit. SE is the squared exponential "
                         "kernel, which is good for core data. gibbstanh is the "
                         "Gibbs kernel with tanh warping of the length scale. "
                         "This kernel allows the entire profile to be fit at "
                         "once, and should be used if you have edge data.")
parser.add_argument('--coordinate',
                    choices=['psinorm', 'Rmid', 'r/a', 'volnorm', 'phinorm',
                             'sqrtpsinorm', 'sqrtr/a', 'sqrtvolnorm', 'sqrtphinorm'],
                    default='psinorm',
                    help="Which coordinate to fit against. Note that this does "
                         "not have an effect if data are pulled from a NetCDF "
                         "file.")
parser.add_argument('--core-only',
                    action='store_true',
                    help="Set this flag to only fit the data in the core. This will "
                         "default to using a squared exponential kernel.")
parser.add_argument('--robust',
                    action='store_true',
                    help="Set this flag to use robust estimators (median, IQR) "
                         "when performing time-averages.")
parser.add_argument('--all-points', '--no-average',
                    action='store_true',
                    help="Set this flag to keep all points from the time window "
                         "selected instead of performing a time average. This "
                         "will make the fit take longer and is statistically-"
                         "questionable, but may be useful in some cases.")
parser.add_argument('--outlier-threshold',
                    type=float,
                    help="If provided, any points whose value is more than this "
                         "many times its own error bar outside of the fit will "
                         "be rejected.")
parser.add_argument('--random-starts',
                    type=int,
                    help="The number of random starts to use when trying to find "
                         "the MAP estimate for the hyperparameters. If you are "
                         "getting bad fits, try increasing this. If not "
                         "specified, this is set to the number of processors "
                         "available on your machine.")
parser.add_argument('--bounds',
                    type=float,
                    nargs='+',
                    help="Bounds to use for each of the hyperparameters. "
                         "Specified as pairs of lower, upper bounds. If present, "
                         "there should be two such pairs for the squared "
                         "exponential kernel and five such pairs for the Gibbs "
                         "kernel with tanh length scale warping. If not specified, "
                         "somewhat intelligent guesses are made based on the data "
                         "itself. If you are getting bad fits, try tweaking these.")
parser.add_argument('-i', '--input-filename', '--input',
                    help="Filename/path to a NetCDF file containing the profile "
                         "data to be fit.")
parser.add_argument('-o', '--output-filename', '--output',
                    help="Filename/path to write a NetCDF file to containing the "
                         "results of the fit. If not specified, you will be "
                         "prompted for a filename upon completing the fit.")
parser.add_argument('-x', '--abscissa-name',
                    default='x',
                    help="Name of the variable in the input/output NetCDF files "
                         "that contains the values of the abscissa (independent "
                         "variable). The uncertainty in the abscissa must then "
                         "be in err_ABSCISSA_NAME, if present. Note that "
                         "uncertainties in the abscissa are NOT used in the "
                         "profile fit at present, but will be shown on the plot.")
parser.add_argument('-y', '--ordinate-name',
                    default='y',
                    help="Name of the variable in the input/output NetCDF files "
                         "that contains the values of the ordinate (dependent "
                         "variable). The uncertainty in the ordinate must then "
                         "be in err_ORDINATE_NAME, if present.")

args = parser.parse_args()

if args.input_filename:
    if (args.shot or args.signal or args.system or args.t_point or args.t_max or
        args.t_min or args.robust or args.coordinate):
        print("Warning: specifying an input NetCDF file overrides specification "
              "of shot, signal, system, t-point, t-min, t-max, robust and "
              "coordinate. Values given with these flags will only be used to "
              "generate plot labels and metadata.")
    # Read input NetCDF file:
    with scipy.io.netcdf.netcdf_file(args.input_filename, mode='r') as infile:
        vX = f.variables[args.abscissa_name]
        X = X[:]
        try:
            X_units = vX.units
        except AttributeError:
            X_units = ''
        try:
            err_X = f.variables['err_'+args.abscissa_name]
        except KeyError:
            err_X = 0
        
        vy = f.variables[args.ordinate_name]
        y = y[:]
        try:
            y_units = vy.units
        except AttributeError:
            y_units = ''
        try:
            err_y = f.variables['err_'+args.ordinate_name]
        except KeyError:
            err_y = 0
        
        p = profiletools.BivariatePlasmaProfile(
            X_dim=1, X_units=X_units, y_units=y_units,
            X_labels=args.abscissa_name, y_label=args.ordinate_name
        )
        p.add_data(X, y, err_X=err_X, err_y=err_y)
        if args.shot:
            p.shot = args.shot
        # TODO: Might want to fill in other fields to enable other
        # functionality...
        
elif args.shot and args.signal:
    # Create relevant object:
    profile_kwargs = {}
    if args.system:
        systems = set(args.system)
        if 'TS' in systems:
            systems.remove('TS')
            systems.add('ETS')
            systems.add('CTS')
        profile_kwargs['include'] = systems
    if parser.signal == 'ne':
        p = profiletools.ne(args.shot, abscissa=args.coordinate,
                            t_min=args.t_min, t_max=args.t_max)
    elif parser.signal == 'Te':
        p = profiletools.ne(args.shot, abscissa=args.coordinate,
                            t_min=args.t_min, t_max=args.t_max)
    # TODO: Need to handle averaging versus axis dropping versus point selecting!
else:
    print("Error: Must either specify an input file or a shot number, signal and time!")
    sys.exit(1)
